<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nCoV 疫情数据可视化</title>
      <link href="/2020/nCoV-%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2020/nCoV-%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><img src="https://drafff.oss-cn-beijing.aliyuncs.com/img/20200209015914.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎片收容计划 Debris-Containment-Project</title>
      <link href="/2020/%E7%A2%8E%E7%89%87%E6%94%B6%E5%AE%B9%E8%AE%A1%E5%88%92-Debris-Containment-Project/"/>
      <url>/2020/%E7%A2%8E%E7%89%87%E6%94%B6%E5%AE%B9%E8%AE%A1%E5%88%92-Debris-Containment-Project/</url>
      
        <content type="html"><![CDATA[<p><img src="http://pic.drafff.art//drafff/20200128020242.gif" alt></p><blockquote><p>一个匿名留言板，用于收容人们的碎片.</p></blockquote><p>📦：<a href="http://something.drafff.art/dcp/" target="_blank" rel="noopener">http://something.drafff.art/dcp/</a></p><p>🔗：<a href="https://github.com/Drafffffff/Debris-Containment-Project" target="_blank" rel="noopener">https://github.com/Drafffffff/Debris-Containment-Project</a></p><h2 id="Project-setup"><a href="#Project-setup" class="headerlink" title="Project setup"></a>Project setup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="Compiles-and-hot-reloads-for-development"><a href="#Compiles-and-hot-reloads-for-development" class="headerlink" title="Compiles and hot-reloads for development"></a>Compiles and hot-reloads for development</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="Compiles-and-minifies-for-production"><a href="#Compiles-and-minifies-for-production" class="headerlink" title="Compiles and minifies for production"></a>Compiles and minifies for production</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h2 id="Customize-configuration"><a href="#Customize-configuration" class="headerlink" title="Customize configuration"></a>Customize configuration</h2><p>See <a href="https://cli.vuejs.org/config/" target="_blank" rel="noopener">Configuration Reference</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google InnoCamp Winter 2020</title>
      <link href="/2020/Google-InnoCamp-Winter-2020/"/>
      <url>/2020/Google-InnoCamp-Winter-2020/</url>
      
        <content type="html"><![CDATA[<p>👾👾</p><p><img src="http://pic.drafff.art//drafff/20200118161454.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.色彩理论简史 #Programming Design System</title>
      <link href="/2020/7-%E8%89%B2%E5%BD%A9%E7%90%86%E8%AE%BA%E7%AE%80%E5%8F%B2-Programming-Design-System/"/>
      <url>/2020/7-%E8%89%B2%E5%BD%A9%E7%90%86%E8%AE%BA%E7%AE%80%E5%8F%B2-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<p>跟我们在前面章节讲的相比，这里突然来个色彩理论简史可能会让你觉得非常困惑。尽管对色谱有些基本理解很容易，但其实色彩理论是建立在科学和艺术上几乎无限复杂的主题。所以我们很难学会同时适用于科学和艺术的色彩理论，我也看到很多设计师在最基本的问题上被绊到：黄色是三原色之一吗？哪些颜颜色放一起是和谐的？蓝色的补色是什么？</p><p>我希望关于色彩理论的这一章节能够帮你解决一些色彩方面的困惑。在下面简短的介绍中，我对两个不同又相关的领域关于色彩的冲突非常感兴趣：艺术色彩理论，它关注艺术作品中色彩搭配的视觉效果；科学色彩理论，它通过越来越复杂的但越来越精确的色彩模型来描述色彩的本质。接下来的章节将会建立在本章的基础之上，并且我相信这些色彩的历史对设计师做出正确的颜色选择至关重要。</p><p>关于颜色的最早已知理论可以在古希腊的《论色彩》<em>（On Colors）</em>中找到。这篇短文最早被认为是亚里士多德写的，但现在普遍认为是他们<strong>逍遥学派</strong> <em>(Peripatetic school)</em>的其他成员所著。根据观察颜色在自然中的直观呈现，文章中说所有颜色都存在于一个亮和暗之间的光谱中，并且四原色来自于四种元素：火，空气，水和土地。这种推测今天看来非常不靠谱，但是当时的这些观察还是很有意义的：植物的地上部分是绿色的，地下部分是白色的，因此颜色必须来自太阳。同样干燥的植物将失去鲜艳的颜色，因此水也可以提供色彩。这个理论是几个世纪以来颜色理论家用颜色构建宇宙理论的典型代表。尽管理论是错的，但《论色彩》<em>（On Colors）</em>有一系列重要的发现，例如通过观察云层变厚就会变暗[2]“黑暗根本不是一种颜色，只是没有光线罢了。”[1]</p><p>像许多其他科学领域一样，艾萨克·牛顿（Isaac Newton）在1704 年出版第一版《<em>光学</em>》<em>（Opticks）</em>时，完全颠覆有关光的传统理论。牛顿并没有把光当作虚空，而是发现白光是色谱中所有颜色的结合。他的实验是一个众所周知的现象：当白光通过棱镜时，会散射成多种颜色。但是，牛顿发现他可以重新组合这些光谱色，再次将它们变成白光。</p><p>牛顿还发现。如果他将色谱中的第一种颜色（红色）和最后一种颜色（紫色）混合，将会出现一种彩虹中不存在的颜色——洋红色。这使他将色谱图做成了一个圆环，开始了用基本形状表示颜色之间关系的传统。把色谱做成圆形，使得牛顿可以用两种颜色在色环上的中间色来预测两种颜色光混合的结果。牛顿画出的色环上每种颜色相隔的距离都不一样，因为他希望有和每周天数一样多的颜色数。[3]</p><p><img src="http://pic.drafff.art//drafff/20191229200425.png" alt></p><blockquote><p>牛顿的色环使用从音乐中的D调映射到乐理中八度的七种颜色。</p></blockquote><p>当牛顿对色彩的科学解释感兴趣时，德国诗人沃尔夫冈·冯·歌德（Wolfgang von Goethe）将他的《色彩理论》<em>(Theory of Colors）</em>用于以人为中心的色彩感知分析。通过一系列测量眼睛对某些颜色的反应的实验，歌德创造了有史以来最著名的色环。该色环具有三种原色：洋红色，黄色和蓝色。他认为可以通过三原色混合出色谱中的所有颜色。</p><p><img src="http://pic.drafff.art//drafff/20191229203022.png" alt></p><blockquote><p>歌德的色环</p></blockquote><p>这本书在许多方面与牛顿的理论背道而驰，因为歌德认为棱镜是产生颜色的原因而不是光，并且黑暗并不是因为没有光。尽管牛顿最终赢得了有关光的本质的争论，但歌德的工作对我们而言却同样重要，因为它着重于色彩对人类认知的作用。他对残像和视错觉的研究特别有趣，它指向了约翰尼斯·伊滕<em>（Johannes Itten）</em>和约瑟夫·阿尔伯斯 <em>( Josef Albers)</em> 后期的作品[4]。</p><p>牛顿和歌德的色环似乎相互矛盾，其实它们在某种程度上都是正确的，因为它们说明了不同材料中的颜色行为。牛顿描述了他的光谱颜色如何混合，这是正确的，因为光以加法的方式混合：混合不同颜色的光最终会产生白光。歌德描述了他的三原色如何混合，这也是正确的，因为颜料以减法得方式混合：组合不同颜色的颜料最终会黑色颜料。</p><p><img src="http://pic.drafff.art//drafff/20191229203442.svg" alt></p><blockquote><p>RGB颜色模式是加色混合。</p></blockquote><p><img src="http://pic.drafff.art//drafff/20191229203458.svg" alt></p><blockquote><p>CMYK颜色模式是减色混合</p></blockquote><p>为了创建统一的颜色符号（就像音乐符号那样），艺术家很快就开始将色谱描述为3D的实体。托拜厄斯·梅耶<em>(Tobias Mayer）</em>在1775年死后出版的《颜色的亲和力》<em>（The Affinity of Color Commentary）</em>中可以找到类似的例子。梅耶（Mayer）试图准确定义人眼可以看到的各种颜色的数量，这要求他增加另一个维度来代表每种颜色的亮度变化。梅耶用绘画中的三种传统原色（红，黄，蓝）绘制了三角形，并通过将对立的颜色混合在一起来连接这些角。与传统的色环不同，他通过将不同亮度的三角形相互堆叠而创建了色彩三角形的许多变体。这样就可以通过其在3D空间中的位置来定义颜色，这一方式至今仍在使用。梅耶最终并未创建出完美渐变的颜色模型，因为他不了解人眼的不规则之处。[5]</p><p><img src="http://pic.drafff.art//drafff/20191229204655.png" alt></p><blockquote><p>梅耶的色彩三角形。</p></blockquote><p>德国画家菲利普·奥托·朗格（Philipp Otto Runge）在创建球形的色谱时也采用了相同的方法，这个色彩球发表在1810 年的《彩色球形》<em>(Color Sphere manuscript)</em>手稿中。但是，与之前的许多其他颜色模型一样，该模型无法区分亮度和饱和度，这意味着模型的颜色饱和度几乎没有变化。该球体与Mayer三角形具有相同的问题，色阶在感知上并不统一<em>（the steps were not perceptually uniform）</em>[6]。</p><p><img src="http://pic.drafff.art//drafff/20191229205055.png" alt></p><blockquote><p>菲利普·奥托·朗格（Philipp Otto Runge）的彩色球。</p></blockquote><p>米歇尔·欧根·雪佛勒<em>(Michel Eugène Chevreul)</em>从1839年开始尝试在他的半球形色彩系统中解决此问题。他不是通过专注于所用颜料的数量来混合颜色，而是仅根据感觉来决定。受歌德作品的启发，·雪佛勒使用残像测试了颜色混合的有效性。当一个人长时间盯着一个绿色的正方形然后看着白色的墙壁时，会出现一个洋红色的正方形。发生这种情况是由于眼睛中绿色感光细胞的疲劳，·雪佛勒以此在他的模型建立了互补色。[7]</p><p><img src="http://pic.drafff.art/drafff/20191229205452.png" alt></p><blockquote><p>米歇尔·欧根·雪佛勒的色球</p></blockquote><p>美国画家阿尔伯特·亨利·孟塞尔（Albert Henry Munsell）在1900年代初期创造了最具历史意义之一的色彩模型。像许多前辈一样，孟塞尔想要创建一个具有感知统一的模型。虽然孟塞尔是一个画家，但他的方法却非常的科学：他请了许多人来当他的实验对象并和他发明的一系列仪器结合创建了非常精确的模型。这个模型的重点是，他将颜色划分为了三个新的维度：色相，确定了颜色的类型（红色，蓝色等），明度确定了色彩的亮度（浅色或者深色），以及纯度，决定了颜色的饱和度。至今为止，这些标准还在RGB颜色模型的某些形式中使用。</p><p><img src="http://pic.drafff.art//drafff/20191230083913.png" alt></p><blockquote><p>从1943年的表示方法中直观地看到阿尔伯特·亨利·孟塞尔的色彩空间。</p></blockquote><p>孟塞尔首先尝试将颜色排列在一个球体中，但要注意的是“他在努力寻找合适的形状时，例如三棱锥，圆锥或者立方体，以及缺乏相应的测试，导致了许多颜色关系的错误。”[8]本质上来讲，孟塞尔意识到颜色模型必须具有不规则的形状才能适合所有的颜色。原因很简单，暗色在最小饱和度与最大饱和度之间的可见颜色相比亮色要少得多（亮度为零的颜色只有一种黑色）。同样某些色调具有更大色彩的范围，红色与白色混合出的颜色要比黄色多得多，因为黄色是较浅得颜色。孟塞尔得颜色系统的另一个重要细节是他跟喜欢用数学的方式而不是颜色名称来表示颜色在色彩空间中的位置。这和我们今天在编程语言中定义颜色的方式类似。孟塞尔的色彩体系有其缺陷和矛盾之处，但它设法以前所未有的方式将艺术与科学联系在了一起。</p><p>20世纪初期许多的欧洲艺术运动都对艺术的主观体验产生了浓厚的兴趣，尽管德国的包豪斯是一所专注于现代艺术，设计和建筑方法的学校，但有两本关于色彩的重要著作Johannes Itten [9]撰写的《色彩的艺术》<em>( The Art of Color )</em>和Josef Albers [10]撰写的<em>《色彩</em>的互动》 <em>(Interaction of Color)</em>。</p><p>作为马兹达斯南 <em>(Mazdaznan religion)</em> 宗教的追随者，伊藤的艺术观在很大程度上受到其精神信仰的影响。严格素食后，他以与学生一起进行有节奏的呼吸运动以使他们充分发挥创造力而闻名[11]。他的观点与歌德类似，重要的是色彩的主观体验，他的书着重于如何将搭配色彩来唤起观众的感受。伊藤的中心思想是颜色存在七种对比，艺术家必须掌握七种色彩对比才能了解颜色选择的效果。有些对比非常简单，例如当不同亮度的颜色彼此相邻时会出现明暗对比，或者当色调不同的颜色一起使用时会有色调对比[12]。设计师可以使用这些结论来指导他们对颜色的决策，因为这为我们提供了一种颜色进行分类并系统地思考的方法。伊藤甚至使用与上文提到的朗格极为相似的RYB色球进行试验，来解释这些想法。伊藤的其他对比理论相当武断，例如他的同时对比度定律 <em>（ law of simultaneous contrast）</em> 规定了某些颜色一起使用时产生的视觉效果。伊藤经常利用自己的主观经验来建立关于色彩和感知理论，如下面引用所示。</p><blockquote><p>在许多问题上，客观的结论要胜于主管的偏爱。因此可以用浅绿色和蓝绿色调装饰肉类市场，从而使各种肉类看起来更红更新鲜。如果一名商业艺术家要设计一个带有黄白条纹的咖啡包装，或者是带有蓝色原点的意大利面的包装，那就会出现问题，因为这些颜色和主体物冲突。</p><p>约翰内斯·伊滕[13]</p></blockquote><p>其中，伊藤对颜色的个人喜好导致了对颜色和对象的不必要限制。谁说在设计食品标签时不能合理的使用黄色条纹或者蓝色圆点?</p><p>约瑟夫·阿尔伯斯（Josef Albers）是伊藤的学生，他在1963年的《色彩的互动》<em>(Interaction of color)</em>中采用了更具示范性的方法。阿尔伯斯使用不透明的彩色纸片，展示了色彩的高动态性。特别是人类如何感知色彩，感知的颜色取决于它周围的颜色。阿尔伯斯没有尝试建立这种色彩性质的统一理论，而是描述了学生如何重复这些实验来体验色彩。这使得《色彩的互动》在成为色彩构成领域的经典著作。下图是他最著名的例子之一，在彩色背景上有两个小方块。观看者自然会觉得画面中间的正方形颜色不同，而实际上它们是完全相同的颜色。</p><p><img src="http://pic.drafff.art//drafff/20191230095008.png" alt></p><p><img src="http://pic.drafff.art//drafff/20191230095056.png" alt></p><p>如上所述，我们的艺术史充满了关于原色的争论，这是由于对减色和加色模型的困惑所致。众所周知，很难将黄色与深色混合，所以歌德和其他艺术家将黄色视为一种“纯”色。今天我们知道，原色实际上是一个相当随意的概念，并且没有颜料的“纯”原色之类的东西。可以选择任意三种颜色来混合出色谱的一个子集。尽管某些原色可以混合出广泛的颜色，但是不可能在减色模型中混合整个可见色谱。</p><blockquote><p>结论是原色只是一种实用的假设。它们要么是色彩数学模型中采用的虚构变量，要么是在对灯光、油漆、染料或者油墨进行特定的色彩混合时采用的经济上的折中方案。</p><p>布鲁斯·麦克埃维（Bruce MacEvoy）[14]</p></blockquote><p>这些理论已经深深集成到我们每天使用的设备中了。台式打印机和其他减色模式的颜料打印机的行业标准是CMY，它具有三种基本颜色：青色，品红色和黄色。这组特定颜色的墨水可以混合出大部分的颜色。打印机还另需黑色的墨水，因为这些原色不能混合出纯黑色。专业的打印机会有跟多的墨盒，以获得更好的颜色精度。数字印刷技术的领导者爱普生（Epson）在其UltraChrome®HDR技术中使用了十种墨水颜色。</p><p>计算机屏幕和其他具有加色模式的光学显示技术的行业标准是RGB颜色模式，每个像素具有三个基色：红色，绿色和蓝色。这三种颜色可以混合出大部分可见光的颜色。如今任何的数字设计工具都允许设计师基于这三种原色来定义颜色。RGB和CMY颜色模式的一个好处是，即使它们的原色不同，它们颜色之间的补色还是一样的。</p><p><img src="http://pic.drafff.art//drafff/20191230101637.png" alt></p><blockquote><p>RGB和CMY共享补色。</p></blockquote><p>就像今天对色彩的科学性质达成共识一样，人类对色彩的体验是一种高度复杂和主观的现象。普遍认为，不可能创建一种简单、可预测的色彩和谐理论，即歌德和伊滕所信奉的那种方法。许多因素决定了你对特定色彩组合的反应，包括性别，年龄，情绪，个人背景和当前社会趋势[15]。从某种意义上说，这应该是设计师的一种解脱。首先，他们不必参与有关哪个色环具有“正确”互补色的讨论。而且，由于没有简单的理论来寻找合适颜色，学生别无选择，只能用自己的眼睛。</p><p>阅读有关艺术家和科学家的文章时，看到他们将自己的人生奉献在创建颜色模型上，以帮助其他艺术家做出有关色彩构成的决定。那么应该很清楚，当今的设计师与色彩交互的方式（拾色器）还有很多可以改进的地方。拾色器在它出现后就无处不在：过去的十年中，拾色器没有任何重大变化，即使这种模型已经存在了300多年，他无法提供完善的色谱可视化图像。它用了一个矩形区域，一次显示单个色调，设计师无法可视化所选颜色之间的关系，甚至无法理解在感知上统一的颜色模型与其选择颜色之间的差异。</p><p>幸运的是，本书并不局限于数字设计工具。在以下各章中，我们将研究颜色模型，颜色空间以及用于在代码中生成颜色方案的多种技术。为了避免与前辈们犯同样的错误，这些章节不会提出一种统一的理论，即哪种颜色最适合某些情况。相反，我们将了解调色板，并学习如何查看不同颜色组合的效果。希望这能学生们建立扎实的理论基础，以此为基础进行实践。</p><hr><ol><li>Loeb Classical Library (1936) <em>Aristotle’s Minor Works</em>, p. 7. London</li><li>Gottschalk, H. B. (1964) <em>The De Coloribus and Its Author</em>, p. 59-85. Hermes 92. Bd..H. 1: JSTOR. Web. 11 Jan. 2017</li><li>Ball, Philip (2003) <em>Bright Earth: Art and the Invention of Color</em>, p. 25. University of Chicago Press</li><li>Sloane, Patricia (1967) <em>Colour: Basic Principles New Directions</em>, p. 28-30. Studio Vista</li><li>Lowengard, Sarah (2006) <em>The Creation of Color in Eighteenth-Century Europe New York</em>, para. 129-139, Columbia University Press)</li><li>Ball, Philip (2003) <em>Bright Earth: Art and the Invention of Color</em>, p. 48. University of Chicago Press</li><li>Ball, Philip (2003) <em>Bright Earth: Art and the Invention of Color</em>, p. 175-176. University of Chicago Press</li><li>Munsell, A.H (1912) <em>A Pigment Color System and Notation</em>, pp. 239. The American Journal of Psychology. Vol. 23. University of Illinois Press</li><li>Itten, Johannes (1973) <em>The Art of Color: the subjective experience and objective rationale of color</em>. Van Nostrand Reinhold</li><li>Albers, Josef (1963) <em>Interaction of Color</em>. Yale University</li><li>Droste, Magdalena (2002) <em>Bauhaus</em>, p. 25. Taschen</li><li>Itten, Johannes (1970) <em>The Elements of Color</em>, p. 33-44. Van Nostrand Reinhold</li><li>Itten, Johannes (1970) <em>The Elements of Color</em>, p. 26. Van Nostrand Reinhold</li><li>MacEvoy, Bruce. <em>Color Vision</em> Handprint : Colormaking Attributes. N.p., 1 Aug. 2015. Web. 11 Jan. 2017.</li><li>O’Connor, Zena (2010) <em>Color Harmony Revisited</em>, p. 267-273. Color Research and Application. Volume 35, Issue 4</li></ol><p>本文译自<a href="https://programmingdesignsystems.com/" target="_blank" rel="noopener">Programming Design Systems</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.程序化的形状(Procedural Shapes)  #Programming Design System</title>
      <link href="/2020/6-%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%9A%84%E5%BD%A2%E7%8A%B6-Procedural-Shapes-Programming-Design-System/"/>
      <url>/2020/6-%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%9A%84%E5%BD%A2%E7%8A%B6-Procedural-Shapes-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<p>​    到目前为止，我们自定义形状的代码还是非常繁琐。我们通过逐行输入顶点函数来手动创建形状，用这种方法碰到更加复杂的形状就会爆炸，根据我们的书名，这种方法不太适合。现在我们知道了<code>beginShape()</code>的用法，接下来我们要用<code>for</code>循环和<code>sin()</code>和<code>cos()</code>函数以程序化的方式绘制自定义形状。</p><h2 id="正弦和余弦"><a href="#正弦和余弦" class="headerlink" title="正弦和余弦"></a>正弦和余弦</h2><p>多年来，我已经看到了许多同学面对<code>sin</code>和<code>cos</code>函数苦苦挣扎。原因也很容易理解：这些词看起来相当吓人和抽象，尤其是当你自认为不擅长数学的时候。这既不幸，又没必要。不幸的是，这两个函数是大多是程序设计的基本组成部分，并且对它们充分理解能够解决你许多视觉上的问题。没有必要是因为它们并不难学。即使你对本章内容一点也不了解，也可以通过记住两行相同的代码开始。</p><p>正弦和余弦能让我们在圆周上找到任意的位置。它们通过将角度转换为单位圆的<code>x</code>坐标和<code>y</code>坐标来实现。然后再把这些值乘以实际圆得半径来按比例放大。三角函数按照咱们高中学的知识<code>sin</code>就是对边比邻边，<code>cos</code>就是斜边比邻边。</p><p><img src="http://pic.drafff.art//drafff/20191228192203.png" alt></p><p>在P5中，这些函数称为<code>sin()</code>和<code>cos()</code>。它们接受一个以弧度制表示的参数，并返回一个在-1到1 之间的值。下面的两行代码演示了如何获取这些值并将它们乘以实际圆的半径。记住这两行代码，它们非常重要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = cos(RADIANS) * RADIUS;</span><br><span class="line"><span class="keyword">var</span> y = sin(RADIANS) * RADIUS;</span><br></pre></td></tr></table></figure><p>为了说明这点，请看下面的示例。我们用相同的代码在大圆圆周的330°的位置绘制小圆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">translate(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">noFill();</span><br><span class="line"><span class="keyword">var</span> radius = width * <span class="number">0.3</span>;</span><br><span class="line">ellipse(<span class="number">0</span>, <span class="number">0</span>, radius*<span class="number">2</span>, radius*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">fill(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> x = cos(radians(<span class="number">330</span>)) * radius;</span><br><span class="line"><span class="keyword">var</span> y = sin(radians(<span class="number">330</span>)) * radius;</span><br><span class="line">ellipse(x, y, <span class="number">20</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191228192908.png" alt></p><p><code>sin()</code>和<code>cos()</code>函数为那些围绕着一个中心点并且没有重复轮廓的图形（正多边形）提供了一种绘制的思路。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>尽管整本书都在使用<code>for</code>循环，但还是要在这里介绍一下<code>for</code>循环的基本功能。<code>for</code>循环允许我们通过递增或者递减的方式改变一个通常为<code>i</code>变量，知道变量不满足表达式，循环才会停止。在下面的例子中，我们初始化<code>i</code>的值为<code>0</code>，只要我们变量的值小于<code>10</code>，就会进行迭代，并且每次迭代之后变量将递增<code>1</code>。最终这个循环会执行十次，变量会从<code>0</code>递增到<code>9</code>，在画布上绘制十个矩形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191228194128.png" alt></p><p>不幸的是，所有这些矩形的位置和大小相同，<code>rect()</code>一次又一次的接受同样的参数，所有矩形都重叠在一起。<code>i</code>在这个时候就能发挥用处了，每次循环的时候<code>i</code>都会发生变化，通过<code>i</code>就能使矩形产生变化。下面的示例用<code>i</code>将十个矩形放置在<code>x</code>轴上，每个矩形相聚一个像素。</p><p><img src="http://pic.drafff.art//drafff/20191228194534.png" alt></p><p>尽管你现在可能还不能马上理解，但这在绘制图形时是一项重要的技能。因为<code>i</code>在每次迭代的时候都会递增，所以可以用作画布上图形分布的标量。例如，如果我们想让矩形彼此相邻放置，则可以把大于矩形宽度的值乘以<code>i</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  rect(i * <span class="number">105</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191228194846.png" alt></p><p>我们可以用相同的方法绘制自定义形状。我们在循环在<code>beginShape()</code>和<code>endShape()</code>函数之间添加顶点。在下面的示例中，我们用这个方法在画布中间添加十个随机顶点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">translate(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line">beginShape();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = random(<span class="number">-100</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">var</span> y = random(<span class="number">-100</span>, <span class="number">100</span>);</span><br><span class="line">  vertex(x, y);</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191228195129.png" alt></p><h2 id="结合上面说的方法"><a href="#结合上面说的方法" class="headerlink" title="结合上面说的方法"></a>结合上面说的方法</h2><p>我们把上面随机放置的顶点改为沿着圆周按顺序的顶点。这个时候我们之前记住的两行代码就派上了用处。但我们这次传递给<code>sin()</code>和<code>cos()</code>的角度是把圆周分为<code>i</code>份得来的。最终我们得到了一个正十边形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">translate(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line">beginShape();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = cos(radians(i * <span class="number">36</span>)) * <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> y = sin(radians(i * <span class="number">36</span>)) * <span class="number">100</span>;</span><br><span class="line">  vertex(x, y);</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191228195911.png" alt></p><p>通过更矮迭代次数和顶点之间的角度，可以绘制所有基本形状。下面的代码在顶部添加了一些变量，来根据顶点数自动计算间距。更改<code>numVertices</code>变量，将会出现另一个形状。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numVertices = <span class="number">3</span>; <span class="comment">// or 4 or 30</span></span><br><span class="line"><span class="keyword">var</span> spacing = <span class="number">360</span> / numVertices;</span><br><span class="line">translate(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line">beginShape();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = cos(radians(i * spacing)) * <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> y = sin(radians(i * spacing)) * <span class="number">100</span>;</span><br><span class="line">  vertex(x, y);</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191228200210.png" alt></p><p>你可能会说：“太好了，我们发明了新的基本形状函数”。其实我们用这个方法可以绘制更加复杂的形状。我们来看几个例子，它们都用相同的<code>sin()</code>和<code>cos()</code>公式来绘制不同类型的形状。我们将从下面的波浪形圆圈开始，每个顶点的半径都是随机的，看起来就像是手工绘制的。</p><p><img src="http://pic.drafff.art//drafff/20191228200515.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">translate(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">beginShape();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">更改每个顶点的半径</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radius = <span class="number">100</span> + random(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">var</span> x = cos(radians(i * <span class="number">3.6</span>)) * radius;</span><br><span class="line">  <span class="keyword">var</span> y = sin(radians(i * <span class="number">3.6</span>)) * radius;</span><br><span class="line">  vertex(x, y);</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p>通过在每个顶点的高低半径交替，可以创建出下面的星形。使用不同的参数，或用<code>rotate()</code>函数改变星形的方向，我们可以很容易的改变星形的样式。</p><p><img src="http://pic.drafff.art//drafff/20191228200728.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">translate(width/<span class="number">2</span>, height/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将初始半径设置为100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> radius = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">beginShape();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在cos / sin公式中使用半径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x = cos(radians(i * <span class="number">36</span>)) * radius;</span><br><span class="line">  <span class="keyword">var</span> y = sin(radians(i * <span class="number">36</span>)) * radius;</span><br><span class="line">  vertex(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改下一个顶点的半径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(radius == <span class="number">100</span>) &#123;</span><br><span class="line">    radius = <span class="number">50</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    radius = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p>这是用 <code>quadraticVertex()</code>函数创建的花朵， <code>quadraticVertex()</code>所有的控制点和顶点的位置都是通过<code>sin()</code>和<code>cos()</code>生成。使用贝塞尔曲线时，请记住以<code>vertex()</code>函数调用开始。</p><p><img src="http://pic.drafff.art//drafff/20191228201516.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动计算间距</span></span><br><span class="line"><span class="keyword">var</span> numVertices = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> spacing = <span class="number">360</span> / numVertices;</span><br><span class="line"></span><br><span class="line">beginShape();</span><br><span class="line"><span class="comment">//循环一圈，用曲线闭合形状。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numVertices+<span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到顶点的位置</span></span><br><span class="line">  <span class="keyword">var</span> angle = i * spacing;</span><br><span class="line">  <span class="keyword">var</span> x = cos(radians(angle)) * <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> y = sin(radians(angle)) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//如果循环是第一次运行，创建简单顶点。</span></span><br><span class="line">    vertex(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则，创建一个二次Bézier顶点，其控制点位于两点之间的中间，并且半径较大。</span></span><br><span class="line">    <span class="keyword">var</span> cAngle = angle - spacing/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> cX = cos(radians(cAngle)) * <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">var</span> cY = sin(radians(cAngle)) * <span class="number">180</span>;</span><br><span class="line">    quadraticVertex(cX, cY, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p>您会发现自己只需要使用一种循环功能。如下创建两个形状：第一个使用<code>sin()</code>，第二个使用<code>cos()</code>（如下面的代码所示）。</p><p><img src="http://pic.drafff.art//drafff/20191228201657.png" alt></p><p><img src="http://pic.drafff.art//drafff/20191228201706.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">strokeWeight(<span class="number">20</span>);</span><br><span class="line">strokeCap(SQUARE);</span><br><span class="line">translate((width/<span class="number">2</span>) - <span class="number">200</span>, height/<span class="number">2</span>);</span><br><span class="line">beginShape();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line"><span class="comment">//x轴上2个像素间距。</span></span><br><span class="line">  <span class="keyword">var</span> x = i * <span class="number">2</span>;</span><br><span class="line"><span class="comment">//y轴上的200像素高波形。</span></span><br><span class="line">  <span class="keyword">var</span> y = cos(i * radians(<span class="number">2</span>)) * <span class="number">100</span>;</span><br><span class="line">  vertex(x, y);</span><br><span class="line">&#125;</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><p>在设计过程中，可以使用正弦和余弦来创建一系列不同的形状。在约瑟夫·穆勒·布罗克曼（JosefMüller-Brockmann）的设计中，一系列指数增长的圆弧围绕着画布的左下角旋转。</p><p><img src="http://pic.drafff.art//drafff/20191228201816.png" alt></p><p><em>约瑟夫·米勒-布罗克曼的贝多芬海报</em></p><p><em>Sediment Mars</em>是莎拉·哈拉切（Sarah Hallacher）和亚历山德拉·维拉米尔（Alessandra Villaamil）创作的一系列海报。通过<code>sin()</code>和<code>cos()</code>函数，生成一个椭圆形，然后通过添加随机值来让他失真。</p><p><img src="http://pic.drafff.art//drafff/20191228202041.png" alt></p><p><em>莎拉·哈拉切（Sarah Hallacher）和亚历山德拉·维拉米尔（Alessandra Villaamil）的Sediment Mars</em></p><p>Generative Play项目是Adria Navarro的卡片游戏，它使用程序绘图来创建各种各样的生成角色。这些角色的身体是使用<code>sin()</code>和<code>cos()</code>创建的。</p><p><img src="http://pic.drafff.art//drafff/20191228202314.png" alt></p><p><em>Adria Navarro的生成游戏</em></p><p>本章介绍了一种与传统设计过程有本质不同的设计方法。我们没有一个一个去绘制形状，而是编写算法来替我们完成这些任务。使用循环来绘制图形是一种强大的方式，因为它能让程序员用更少的代码做更多的事情，从而减轻了手工绘制每个对象的痛苦。这同时也是程序设计中最难的部分，因为设计人员需要花更多的时间将系统提炼成代码，而且他们不能像传统设计工具那样轻易的操纵单个形状。美国计算机科学家唐纳德·努斯（Donald Knuth）称这是从设计到元设计的过渡：</p><blockquote><p>“元设计(<em>Meta-design</em>)比设计困难得多；解释如何画比画东西难得多。[…]然而，一旦我们成功地解释了如何以足够通用的方式绘制事物，那么在不同情况下，相同的解释将适用于所有形状。因此花时间制定描述如何绘制是值得的。”</p><p>Donald Knuth (1986), The Metafont Book</p></blockquote><p>这也是本书的主要论点，当设计师学会了系统的思考设计过程，并且用软件实现这些系统时，他们能做出以前无法完成的工作。</p><svg width="100%" height="3" xmlns="http://www.w3.org/2000/svg">    <line x1="0" y1="1" x2="100%" y2="1" stroke-dasharray="6, 3" stroke-width="2" stroke="#29b79b"/>  </svg><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>尝试使用本章介绍的技术绘制所有基本形状。然后继续生成其他类型的形状。你可以<code>random()</code>用来操纵形状轮廓吗？可以使用贝塞尔曲线代替简单顶点吗？</p><p>你可以把作业发在下面评论区中。</p><p>本文译自<a href="https://programmingdesignsystems.com/" target="_blank" rel="noopener">Programming Design Systems</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.自定义形状  #Programming Design System</title>
      <link href="/2020/5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6-Programming-Design-System/"/>
      <url>/2020/5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<p>​    </p><p>[TOC]</p><p>​    虽然只用简单形状做设计是一种很好的练习方式，但是复杂的形状将会提供更多的创作的可能性。在动手设计的过程中，复杂的形状通常需要很长的时间才能绘制出来，因为形状的每个细节都需要手动绘制。尽管各大软件公司已经努力让这些工作自动化，但是在目前的数字设计工具（如Adobe illustrator或Sketch）中创建某些复杂形状仍然很繁琐，尤其是需要重复或者随机化的设计（例如振幅发生变化的正弦曲线图案）。在代码中我们能快速的生成这些图案，并且需要的代码还非常简单。另一方面，用笔随意画出的图案很难用代码复现出来，尤其是没有任何规则可以描述这个形状的时候。</p><p>​    在接下来的章节中，我将介绍一系列用代码绘制自定义形状的技术。但是，我们必须首先了解清楚在用代码绘制图形的基本概念，如<code>beginShape()</code>函数和其他许多可用于定义外形的函数。</p><h2 id="编写自定义形状"><a href="#编写自定义形状" class="headerlink" title="编写自定义形状"></a>编写自定义形状</h2><p>​    大多数图形编程语言都允许你绘制自定义形状，就像“连点图”：你需要定义一系列点（我们称为顶点），通过把这些点相连形成形状轮廓。</p><p>​    形状中的每个顶点都决定了它与前一个顶点的连接方式。如果是一个简单的顶点，它将以直线与前一个点连接。如果是一个弯曲顶点，它将以曲线与前一个点连接。如果把最后一个点与第一个点连接，形状可以选择是否变成闭合形状。可以使用<code>beginShape()</code>函数开始一个新的自定义形状，使用不同的顶点函数定义该形状的顶点，最后通过在<code>endShape()</code>函数中调用可选参数来使形状闭合。下面我们讲解一下这些顶点函数。</p><h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p>​    使用<code>vertex()</code>函数创建一个简单的顶点，这个顶点会通过直线与其他顶点连接。所有通过<code>begainShape()</code>创建的形状必须以<code>vertex()</code>开始。下面的示例对此进行了说明。尝试拖动顶点来查看生成的代码。</p><div id="vertex-interactive"><div data-reactroot class="grid"><div class="col-1-2"><svg width="100%" viewbox="0 0 500 400" style="background-color: rgb(241, 241, 241);"><path d="M 171.42857142857142 73.4140037593985 L 352.6315789473684 117.7749060150376 L 220.30075187969925 253.11325187969925 Z" fill="#303030"/><circle class="dragger animate-blink" cx="171.42857142857142" cy="73.4140037593985" r="10" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><circle class="dragger animate-blink" cx="352.6315789473684" cy="117.7749060150376" r="10" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><circle class="dragger animate-blink" cx="220.30075187969925" cy="253.11325187969925" r="10" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/></svg></div><div class="col-1-2"><pre class="no-margin"><code><span class="token function">beginShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">vertex</span><span class="token punctuation">(</span><span class="token number">171</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">vertex</span><span class="token punctuation">(</span><span class="token number">353</span><span class="token punctuation">,</span> <span class="token number">118</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">vertex</span><span class="token punctuation">(</span><span class="token number">220</span><span class="token punctuation">,</span> <span class="token number">253</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">endShape</span><span class="token punctuation">(</span>CLOSE<span class="token punctuation">)</span></code></pre></div></div></div><p>下面的示例都是用简单顶点创建的，但是通过设置描边和填充实现了非常不同的效果。</p><p><img src="http://pic.drafff.art//drafff/20191227134842.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/vertex-arrow.js" target="_blank" rel="noopener">代码</a></p><p><img src="http://pic.drafff.art//drafff/20191227134919.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/vertex-mountain.js" target="_blank" rel="noopener">代码</a></p><p><img src="http://pic.drafff.art//drafff/20191227134939.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/vertex-house.js" target="_blank" rel="noopener">代码</a></p><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p>​    我们需要使用<code>quadraticVertex()</code>和<code>bezierVertex()</code>函数，这两个函数明显要比<code>vertex()</code>更加复杂，因为他们需要一些点的坐标来控制曲线。要知道怎么画出贝塞尔曲线，我们先简要了解下贝塞尔曲线的概念。</p><p>​    在数学的数值分析领域中，贝塞尔曲线（英语：Bézier curve，亦作“贝塞尔”）是计算机图形学中相当重要的参数曲线。</p><p>​    贝塞尔曲线于1962年，由法国工程师皮埃尔·贝兹（Pierre Bézier）推广，他是计算几何学中绘制任意缩放的曲线常见的解决方案。贝兹通过引入控制点优雅的解决了曲线缩放的问题：不可见的重力点吸引了直线并将其弯曲成曲线。具有单个控制点的贝塞尔曲线称为二次贝塞尔曲线，具有两个控制点的贝塞尔曲线称为三次贝塞尔曲线。如果你曾经在Adobe Illustrator中使用过钢笔工具，那么你应该已经熟悉这个概念。</p><p><img src="http://pic.drafff.art//drafff/20191227144404.gif" alt></p><p>该动画显示了如何计算二次贝塞尔曲线。</p><p><img src="http://pic.drafff.art//drafff/20191227144516.gif" alt></p><p>该动画显示了如何计算三次贝塞尔曲线。</p><p>你可以使用<code>quadraticBezier()</code>函数绘制二次贝塞尔曲线，只需传入两个端点，以及一个控制点的坐标。同样的<code>bezierVertex()</code>函数可以绘制三次贝塞尔曲线，需要传入两个端点以及两个控制点的坐标。这两个函数的唯一区别在于，<code>bezierVertex()</code>函数多了以控制点，可以绘制更加复杂的贝塞尔曲线。尝试拖动顶点和控制点以查看生成的代码。</p><div id="curve-interactive"><div data-reactroot class="grid"><div class="col-1-2"><svg width="100%" viewbox="0 0 500 400" style="background-color: rgb(241, 241, 241);"><path d="M 80 100 Q 217.29323308270676 91.93491541353383 354.1353383458646 122.01010338345866 C 430 360 200 170 130 310 Z" fill="#303030"/><circle class="dragger animate-blink" cx="80" cy="100" r="10" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><circle class="dragger animate-blink" cx="354.1353383458646" cy="122.01010338345866" r="10" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><line class="animate-blink" x1="354.1353383458646" y1="122.01010338345866" x2="217.29323308270676" y2="91.93491541353383" style="stroke: rgb(7, 177, 144); stroke-width: 1.5;"/><circle class="dragger animate-blink" cx="217.29323308270676" cy="91.93491541353383" r="6" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><circle class="dragger animate-blink" cx="130" cy="310" r="10" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><line class="animate-blink" x1="130" y1="310" x2="430" y2="360" style="stroke: rgb(7, 177, 144); stroke-width: 1.5;"/><circle class="dragger animate-blink" cx="430" cy="360" r="6" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/><line class="animate-blink" x1="130" y1="310" x2="200" y2="170" style="stroke: rgb(7, 177, 144); stroke-width: 1.5;"/><circle class="dragger animate-blink" cx="200" cy="170" r="6" style="fill-opacity: 0.1; fill: rgb(7, 177, 144); stroke: rgb(7, 177, 144); stroke-width: 2; cursor: move; pointer-events: all;"/></svg></div><div class="col-1-2"><pre class="no-margin"><code><span class="token function">beginShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">vertex</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">quadraticVertex</span><span class="token punctuation">(</span><span class="token number">217</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">354</span><span class="token punctuation">,</span> <span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">bezierVertex</span><span class="token punctuation">(</span><span class="token number">430</span><span class="token punctuation">,</span> <span class="token number">360</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">170</span><span class="token punctuation">,</span> <span class="token number">130</span><span class="token punctuation">,</span> <span class="token number">310</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">endShape</span><span class="token punctuation">(</span>CLOSE<span class="token punctuation">)</span></code></pre></div></div></div><p>掌握贝塞尔曲线需要一定的练习，一开始很难知道一个形状需要几条贝塞尔曲线。尝试去控制这些看不见的控制点是没有用的，所以在深入研究代码之前话一些时间在这些示例上可能会有所帮助。下面三个都是用贝塞尔曲线创建的自定义形状示例。</p><p><img src="http://pic.drafff.art//drafff/20191227145349.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/quad-circle.js" target="_blank" rel="noopener">代码</a></p><p><img src="http://pic.drafff.art//drafff/20191227145401.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/cubic-key.js" target="_blank" rel="noopener">代码</a></p><p><img src="http://pic.drafff.art//drafff/20191227145415.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/cubic-letter.js" target="_blank" rel="noopener">代码</a></p><h2 id="带洞的形状"><a href="#带洞的形状" class="headerlink" title="带洞的形状"></a>带洞的形状</h2><p>当我们用<code>vertex()</code>，<code>quadraticVertex()</code>和<code>bezierVertex()</code>绘制图形时，无法绘制带孔洞的图形。在p5.js中，孔洞称为contour<em>（等高线？）</em>你可以使用<code>beginContour()</code>和<code>endContour()</code>函数来绘制具有孔洞的形状。实际上<code>beginContour()</code>函数表示你开始了一个新的形状，这个形状将会从主形状中减去。和<code>beginShape()</code>一样，你可以使用顶点函数绘制形状，并且使用<code>endContour()</code>结束轮廓。</p><p><img src="http://pic.drafff.art//drafff/20191227150124.png" alt></p><p><a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/contour.js" target="_blank" rel="noopener">代码</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beginShape();</span><br><span class="line">  <span class="comment">// 在这画矩形</span></span><br><span class="line">  beginContour();</span><br><span class="line">    <span class="comment">// 在这画三角形</span></span><br><span class="line">  endContour();</span><br><span class="line">endShape();</span><br></pre></td></tr></table></figure><h2 id="柔软而锋利"><a href="#柔软而锋利" class="headerlink" title="柔软而锋利"></a>柔软而锋利</h2><p>​    你可以继续前面几章的“设计词语”练习。我给学生的作业大概是这样的：设计一个具有黑白两种形状的设计，分别代表“柔软”和“锋利”。这是一项艰巨的任务，原因有很多，首先，学生必须考虑形状和轮廓如何传达这些意思，并且用不同的顶点表示“柔软”和“锋利”。同样这些形状存在于同一画布中能让学生考虑如何让形状互相融合以实现更加生动的效果。</p><p><img src="http://pic.drafff.art//drafff/20191227151615.png" alt></p><p>作者：Luna Chen。<a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/wetsharp-luna.js" target="_blank" rel="noopener">代码</a></p><p><img src="http://pic.drafff.art//drafff/20191227151636.png" alt></p><p>作者：Sean McIntyre。<a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/custom-shapes/wetsharp-sean.js" target="_blank" rel="noopener">代码</a></p><p>​    在本章的代码中定义了许多就像用鼠标绘制出的形状，当然这不是创意编程所要做的事。当用鼠标效率更高时为什么要在代码中生成？在下面的章节中我们将研究更多用更加程序化的方式绘制形状的技术。</p><svg width="100%" height="3" xmlns="http://www.w3.org/2000/svg">    <line x1="0" y1="1" x2="100%" y2="1" stroke-dasharray="6, 3" stroke-width="2" stroke="#29b79b"/>  </svg><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>创建一个具有黑白两部分的作品，分别代表“柔软”和“锋利”。必须使用<code>beginShape()</code>和<code>endShape()</code>函数创建形状。</p><p>你可以把作业发在下面评论区中。</p><p>本文译自<a href="https://programmingdesignsystems.com/" target="_blank" rel="noopener">Programming Design Systems</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.构图  #Programming Design System</title>
      <link href="/2020/4-%E6%9E%84%E5%9B%BE-Programming-Design-System/"/>
      <url>/2020/4-%E6%9E%84%E5%9B%BE-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<p>：<br>​    平面设计是使用形式和颜色传达信息的艺术，但这可没有听起来这么容易。设计是一个反复试验的过程，通常需要反复迭代才能清晰表达出自想说的内容。尽管我们更倾向于把这一过程看作是一种本能，但一个有丰富经验的设计师会有一套不断扩展的设计框架来指导他完成最终的作品。</p><p>​    我们现在来讲整个设计框架中的第一项：构图。在下面，我将会用一个简单的矩形来演示三种简单的构图变化：位置，大小，旋转。以此来达到不同的表达效果。虽然这看起来很基础，但是这些关系是大多数成功设计的关键要素。同时这也是一个介绍视觉传达的好方法。</p><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>​    大多数书面语言都有习惯的阅读方向。西方大多数的国家，字符都是水平排列，我们从左到右，从上到下阅读。这告诉我们，设计中的图形位置能够引导用户的视线。</p><p><img src="http://pic.drafff.art//drafff/20191225142008.png" alt></p><p>按照习惯性的阅读方向，这是开头。</p><p><img src="http://pic.drafff.art//drafff/20191225142056.png" alt></p><p>按照习惯性的阅读方向，这是结尾。</p><p>​    在瑞士汽车俱乐部的这些海报中，约瑟夫·穆勒·布罗克曼（JosephMüller-Brockmann）使用位置（和尺寸）确定了不同些形状的优先级。</p><p>​    在第一个海报中，构图的张力让人觉得左边的摩托车就要撞上孩子。在第二张海报中，自行车上挥手的人让人以为是画面的主体，实际上恰恰相反。</p><p><img src="http://pic.drafff.art//drafff/20191225143303.png" alt></p><p>Joseph Müller-Brockmann <a href="https://programmingdesignsystems.com/shape/figure-and-ground/index.html#fairuse" target="_blank" rel="noopener">©</a></p><p><img src="http://pic.drafff.art//drafff/20191225143335.png" alt></p><p>在p5中，我们使用<code>rect()</code>函数来绘制矩形，传递给此函数的前两个数字确定了矩形在画布中的位置。如果这些数字均为零，那么矩形就会显示在左上角，较大的值会使矩形出现在画布的右侧(<code>x</code>)和底部(<code>y</code>)。这使得代码中定位形状变得容易，大部分图形编程语言都以这种方式工作。</p><p><img src="http://pic.drafff.art//drafff/20191225143854.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">rect(<span class="number">300</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>反复输入随机的数字来调整形状的位置不如用一些基础的数学运算计算出形状的位置。这会使你的画布与图形建立联系，并且会使设计作品的缩放变得更加容易。请看下面的例子。</p><p><img src="http://pic.drafff.art//drafff/20191225144402.png" alt></p><p>​    我们可以使用处于画布中的一个精确的位置坐标来画出这个矩形。但是一旦我们改变了画布的大小，矩形就不再出现在我们想要的位置。我们需要改变矩形<code>x</code> 和<code>y</code>坐标使矩形重新出现在正确的位置。</p><p>​    但是下面的代码就修复了这个问题，其中<code>width</code>和<code>height</code>变量用于动态计算矩形的位置。为了计算<code>x</code>的值，我们从画布右边缘（<code>width</code>）开始，然后减去矩形（<code>100</code>）的大小，最后减去画布边缘和矩形（<code>25</code>）之间我们想要的间隙。该<code>y</code>位置使用相同的公式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rect(width - <span class="number">100</span> - <span class="number">25</span>, height - <span class="number">100</span> - <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>​    通过增加重要形状的大小并减小次要形状的大小，可以使设计更加清晰。从交通标志到文章标题，我们每天都会遇到这种设计模式。</p><p><img src="http://pic.drafff.art//drafff/20191225150034.png" alt></p><p>这个正方形占据了主导地位，因为它占据了大部分画布。</p><p><img src="http://pic.drafff.art//drafff/20191225150120.png" alt></p><p>这个正方形的统治地位比较低，应为其周围有较大的空白空间。</p><p>1959年的“Think small”广告就是一个很好的例子，说明了如何使用大小来强调文本。在这一系列广告中，大众甲壳虫的图像以不同尺寸打印在原本为空的画布上。</p><p><img src="http://pic.drafff.art//drafff/20191225150524.png" alt></p><p>“Think small”海报<a href="https://programmingdesignsystems.com/shape/figure-and-ground/index.html#fairuse" target="_blank" rel="noopener">©</a></p><p><img src="http://pic.drafff.art//drafff/20191225150601.png" alt></p><p>传递给<code>rect()</code>函数的第三个和第四个数字定义了矩形的宽度和高度。和位置一样，根据画布大小动态显示矩形的大小可能非常有用。在上面的示例的基础上，以下代码显示了真正的动态设计，其中用于尺寸和间距的静态数字已由计算代替。现在，矩形的位置和大小都会随着画布自动缩放。</p><p><img src="http://pic.drafff.art//drafff/20191225150952.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rect(width - (height/<span class="number">3</span>) - (width/<span class="number">20</span>), height - (height/<span class="number">3</span>) - (width/<span class="number">20</span>), height/<span class="number">3</span>, height/<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>但是，上面个的代码变得非常难阅读。如果需要改变矩形的位置，则需要花一些时间从代码中解析出每一部分的含义。要解决此问题，在代码顶部用变量来储存这些数字通常会很有帮助。这使得代码更具可读性，后续代码的更改也变得更加容易进行。下面的代码会生成同样的内容，但是现在所有的值都被保存在变量中，这些变量的名称清楚地表明了它们的用途。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> size = height / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> margin = width / <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> x = width - margin - size;</span><br><span class="line"><span class="keyword">var</span> y = height - margin - size;</span><br><span class="line">rect(x, y, size, size);</span><br></pre></td></tr></table></figure><p>让代码显得井井有条非常重要，尤其是当你开始设计多个形状和图形时。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>形状发生旋转时，周围留白的形状会发生变化，这能呈现出形状得动态。</p><p><img src="http://pic.drafff.art//drafff/20191225151940.png" alt></p><p>因为具有对称性，没有旋转的矩形是静态的。</p><p><img src="http://pic.drafff.art//drafff/20191225152106.png" alt></p><p>旋转45°会呈现更加复杂但仍然对称的留白。</p><p><img src="http://pic.drafff.art//drafff/20191225152146.png" alt></p><p>旋转27°时会破坏对称性，并且使矩形呈现出动态。</p><p>​    选装的形状在许多设计中可以找到：为儿童设计的书经常会使用旋转的形状来创造趣味。流行杂志使用旋转的网格系统使内容看起来不那么枯燥，而面向狭窄受众的出版物可能会使用水平和垂直线来暗示内容的质量。</p><p><img src="http://pic.drafff.art//drafff/20191225152508.png" alt></p><p>保罗·兰德（Paul Rand）在儿童书籍的俏皮封面上使用旋转的矩形。</p><p><img src="http://pic.drafff.art//drafff/20191225152528.png" alt></p><p>阿迪达斯Logo中的梯形被旋转以传达速度和活力。</p><p>​    <code>rotate()</code>函数只需一个参数，该数字为弧度制的旋转角度。弧度制是基于圆半径的角度测量单位，圆周上半径长度的弧对应的圆心角为1弧度。因此，借助数学的魔力，一个完整的圆为2π(或大约6.283)弧度。那些对复杂的弧度制不感兴趣的人，<code>radians()</code>函数可以把一个角度制的值转换为弧度制。下面的代码会使画布发生（大约）90°旋转。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rotate(PI/<span class="number">2</span>);</span><br><span class="line">rotate(<span class="number">1.57</span>);</span><br><span class="line">rotate(radians(<span class="number">90</span>));</span><br></pre></td></tr></table></figure><p>​    使用<code>rotate()</code>函数时，不是旋转单个形状，而是旋转整个画布。因为所有形状都是在画布上绘制的，所以所有形状都会旋转。与能够改变原点位置的<code>translate()</code>函数结合，可以精确的实现所需的旋转。</p><p>​    作为例子，我们使用上面个的例子。我们在绘制矩形之前使用了<code>rotate()</code>函数，注意画布是围绕着原点而不是矩形旋转的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> size = height / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> margin = width / <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> x = width - margin - size;</span><br><span class="line"><span class="keyword">var</span> y = height - margin - size;</span><br><span class="line">rotate(radians(<span class="number">10</span>));</span><br><span class="line">rect(x, y, size, size);</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191225155107.png" alt></p><p>​    如果我们希望旋转发生在矩形的左上角附近，那我们必须做一些不太直观的操作。首先，我们首先通过使用<code>translate()</code>函数将画布移动到矩形的位置。再调<code>rotate()</code>函数后，会在变换过的画布上绘制矩形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> size = height / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> margin = width / <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> x = width - margin - size;</span><br><span class="line"><span class="keyword">var</span> y = height - margin - size;</span><br><span class="line">translate(x, y);</span><br><span class="line">rotate(radians(<span class="number">10</span>));</span><br><span class="line">rect(<span class="number">0</span>, <span class="number">0</span>, size, size);</span><br></pre></td></tr></table></figure><p><img src="http://pic.drafff.art//drafff/20191225155424.png" alt></p><p>随着我们深入研究更多的排版，我们将进一步研究如何使用<code>translate()</code>和<code>rotate()</code>制作更加复杂的图形。</p><h2 id="设计一个词"><a href="#设计一个词" class="headerlink" title="设计一个词"></a>设计一个词</h2><p>​    练习这些排版函数的一种好方法是“设计一个词”练习。从字典中选一个形容词，然后通过更改单个矩形的位置，大小和旋转来设计出与形容词感受贴近的图形。这能帮助你建立平面设计最基本的技能之一：创建与内容相对应的视觉效果。</p><p>​    下面演示了”陡峭”的练习。怎么通过一个矩形和三个函数来设计这个词？在词语和位置、大小和旋转之间找联系。你可能会注意到陡度是与旋转相关的：通过旋转矩形，可以使矩形看起来像陡峭的山丘。通过改变大小可以使这座山变高，并且延伸到画布之外。通过改变矩形的位置，可以创建不对成的留白。下面演示了这些步骤。</p><p><img src="http://pic.drafff.art//drafff/20191225160626.png" alt></p><ol><li><p>首先我们旋转矩形，直到它看起来很陡峭。</p><p><img src="http://pic.drafff.art//drafff/20191225160831.png" alt></p></li><li><p>我们更改它的大小，让它破出画布。</p><p><img src="http://pic.drafff.art//drafff/20191225160858.png" alt></p></li><li><p>把矩形往右边稍微移一移，来吸引人的注意。</p></li></ol><p>​    下面的例子展示了更多类似的设计。记住，不是所有的形容词都会这么简单，你会发现自己需要更多的形状。那是下一章的主题，所以不用担心。</p><p><img src="http://pic.drafff.art//drafff/20191225161125.png" alt></p><p>平 <a href="https://github.com/runemadsen/programmingdesignsystems.com/blob/master/examples/shape/figure-and-ground/flat.js" target="_blank" rel="noopener">查看代码</a></p><p><img src="http://pic.drafff.art//drafff/20191225161316.png" alt></p><p>大 <a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/figure-and-ground/big.js" target="_blank" rel="noopener">查看代码</a></p><p><img src="http://pic.drafff.art//drafff/20191225161307.png" alt></p><p>害羞 <a href="https://github.com/runemadsen/programmingdesignsystems.com/tree/master/examples/shape/figure-and-ground/shy.js" target="_blank" rel="noopener">查看代码</a></p><p>这章展示了贯穿本书的主题：以平面设计理论为基础，学习如何在代码中实现这些思想，并通过练习来实践这些概念。尽管这只是进入平面设计领域的第一步，但作品的构图非常重要。经常会在设计作品中发现构图问题，不论是用户界面不突出的重要按钮，还是其他主体在画面中含糊不清的例子。切记不要急于为了好看而做设计，要让基本的概念成为设计过程中的关键部分。</p><svg width="100%" height="3" xmlns="http://www.w3.org/2000/svg">    <line x1="0" y1="1" x2="100%" y2="1" stroke-dasharray="6, 3" stroke-width="2" stroke="#29b79b"/>  </svg><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>从字典中随机选择一些形容词，尝试通过单个矩形的位置，大小和旋转来传达这些形容词的意思。然后请朋友猜测这些图像的意思。</p><p>你可以把作业发在下面评论区中。</p><p>本文译自<a href="https://programmingdesignsystems.com/" target="_blank" rel="noopener">Programming Design Systems</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.什么是设计系统？ #Programming Design System</title>
      <link href="/2020/3-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%EF%BC%9F-Programming-Design-System/"/>
      <url>/2020/3-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%EF%BC%9F-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<p>​    你无论走到哪里，都被系统包围。我们用“系统”一词将一组相互作用的部分描述为一个共同的整体，它们可以像手表一样简单，也可以像我们称为互联网的计算机网络一样复杂。在本书中，“设计系统”一词用于描述一种哲学，鼓励设计人员将其设计规则定义为可以在多个产品上使用的规则。</p><p>​    我们假设自己被要求为当地著名的啤酒厂<em>烈黑啤</em>设计包装。为了确保最终设计符合该产品的定位，我花了大量时间研究和品尝啤酒。最后这个厂商很喜欢我的新设计，他们要求我为剩下的10种啤酒设计包装。现在的问题是，我之前设计的 包装的颜色、排版和插图非常适合浓稠啤酒，但不适用于其他啤酒。我只能为每种单独设计不同的包装，最后所有的包装失去了统一性，啤酒厂没有统一的品牌。</p><p>​    如果在我设计第一个包装时就考虑到这是一个更大的品牌的一部分，那么就会去做一个啤酒厂设计系统。我就不会再去关注特定的啤酒，而是去定义一些列用于不同类型啤酒的视觉样式。这个系统会包括一组相关且又具有足够差异来区分单个啤酒的字体和颜色，还能够识别啤酒厂整体的品牌。只有在创建了这个设计系统后，我才能设计第一个标签。</p><p>​    <img src="http://pic.drafff.art//drafff/20191224170346.jpg" alt></p><blockquote><p>1970年为纽约运输局创建的《图形标准手册》是设计系统的一个示例。 它拥有超过350页，为与纽约地铁相关的所有标牌定义了视觉指南。 ©</p></blockquote><p>设计系统提供了一种不同的思维方式，在这种方式中，设计师会被迫考虑许多场景和约束，而不是针对一个单一的产品做设计。这当然不是一种新鲜的设计方式，有人可能会说这一直是设计师工作的一部分。多年来，已经创建了数千种设计系统，从《纽约公交管理局图形标准手册》到Google的《Material Design》。大多数世界500强公司之所以能够被认可是有原因的:他们为产品线中的产品的版式，颜色定义了严格的规则。</p><p><img src="http://pic.drafff.art//drafff/20191224170955.jpg" alt></p><blockquote><p>Google创建的Material Design规范是为了帮助解释公司视觉语言背后的想法。 包括了使用颜色，分层和动画的规则。</p></blockquote><p>一个较新的案例是Pentagram创建的MIT Media Lab Logo。这个想法很简单：填充一个7*7的网格，来创建黑白抽象字母或者符号。这个系统为实验室的23个研究小组创建了带有缩写的Logo，并且作为构建自定义字体，图标和图案的基础。</p><p><img src="http://pic.drafff.art//drafff/20191224171642.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224171648.jpg" alt></p><blockquote><p>MIT Media Lab 设计系统。<a href="https://programmingdesignsystems.com/what-is-a-design-system/index.html#fairuse" target="_blank" rel="noopener">©</a></p></blockquote><p><img src="http://pic.drafff.art//drafff/20191224171728.jpg" alt></p><p>这个Logo是使用设计系统为设计项目赋予一致外观和独特风格的绝佳案例。它既简单又灵活，并且几乎有无限的设计空间。</p><p>设计系统在今天尤为有趣，因为数字产品就是一个系统，写代码的设计师也不用再局限于印刷手册上的设计系统。编程不仅使设计师可以设计东西，还能让设计师设计系统来生成东西。当然，这会花费更多的时间来用代码制定系统规则，但是设计师可以拜托传统设计软件所施加的限制。美国计算机科学家唐纳德·克努斯<em>(Donald Knuth)</em>写下了这件事：</p><blockquote><p><em>“元设计比一般的设计困难得多；解释东西怎么画比画东西要困难得多。其中的一个原因是没办法一次想出所有的潜在规则，另一个原因是要把该做的一切事情都告诉计算机。但是，一旦我们成功地解释了一个足够普遍的设计方法，那么在不同的条件下也能自动生成适应情况的设计。因此花时间制定精确的规则是值得。”</em></p><p><em>唐纳德·努斯（Donald Knuth）（1986），《元字体书》</em></p></blockquote><p>“一个足够普遍的设计方法”非常重要。  能够使编写的程序在允许的范围输出内容,并且能在极短的时间内生成设计作品的变体。无论是生成45000个不同Logo，构建具有不同星球得无限星系，还是创建可以根据地图来改变形态得物品，生成式的设计能力是使用代码做设计的强大之处之一。</p><p><img src="http://pic.drafff.art//drafff/20191224175930.jpg" alt></p><p>保罗·兰德（Paul Rand）设计的海报。<a href="https://programmingdesignsystems.com/what-is-a-design-system/index.html#fairuse" target="_blank" rel="noopener">©</a></p><p><img src="http://pic.drafff.art//drafff/20191224180039.png" alt></p><p>使用代码生成得相似海报。</p><p>在这本书中我们将会研究，设计师要构建怎样得设计系统并且怎么把这些设计系统使用代码构建出来。</p><p>本文译自<a href="https://programmingdesignsystems.com/" target="_blank" rel="noopener">Programming Design Systems</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.设计系统的历史 #Programming Design System</title>
      <link href="/2020/2-%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2-Programming-Design-System/"/>
      <url>/2020/2-%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<p>平面设计是一种相对年轻的表达方式，主要是应了工业革命的需求而生。</p><hr><h2 id="文艺复兴早期"><a href="#文艺复兴早期" class="headerlink" title="文艺复兴早期"></a>文艺复兴早期</h2><p><img src="http://pic.drafff.art//drafff/20191223220922.jpg" alt="img"></p><p>自从1400年代初期发明了可移动印刷品以来，书籍设计就是一种主要着眼于可读性的工艺。版面中规中矩，很少有标题。 图片使用的非常谨慎，主要用于充当标志。 书籍几乎只是充当口语交流的媒介。</p><h2 id="威廉·爱迪生·德维金斯"><a href="#威廉·爱迪生·德维金斯" class="headerlink" title="威廉·爱迪生·德维金斯"></a>威廉·爱迪生·德维金斯</h2><p><img src="http://pic.drafff.art//drafff/20191223220933.jpg" alt="img"></p><p>​    威廉·艾迪生·德维金斯（William Addison Dwiggins）在1922年创造了“平面设计(graphic design)”一词来描述他的书籍设计过程，将排版，插图和设计结合在一起。书籍设计从简单的手工艺变为解释性艺术。 德维金斯是哈佛大学出版社的主任，也是波士顿书法家协会的创始人。 他出生于1880年，当时正是Linotype排字机的发明时间。</p><p>​    </p><p><img src="http://pic.drafff.art//drafff/20191223222150.jpg" alt></p><p>德维金斯（Dwiggins）的这本书的封面展示了这种新的思维方式：视觉与阅读同等重要，排版和插图有重要的意义。 德维金斯一生都从事广告工作，并于1928年出版了《广告布局》。</p><hr><h2 id="未来主义，达达主义和荷兰风格派运动"><a href="#未来主义，达达主义和荷兰风格派运动" class="headerlink" title="未来主义，达达主义和荷兰风格派运动"></a>未来主义，达达主义和荷兰风格派运动</h2><p>在20世纪初的同一时间，许多艺术运动对平面设计的发展产生了影响。 其中最重要的是未来主义，达达主义和荷兰风格派运动。 这些运动对图形形式的产生了巨大的影响，因为这破除了高级艺术与日常设计之间的鸿沟。 下面是1927年的未来主义宣言。</p><p><img src="http://pic.drafff.art//drafff/20191223224257.jpg" alt></p><p>随着许多意大利艺术家宣誓放弃传统艺术，未来主义开始了，他们试图形象化未来，技术和工业革命。 在图形艺术中，这意味着要进行版式，几何形式和颜色的实验。 文字不再是图形艺术中的禁区。</p><p><img src="http://pic.drafff.art//drafff/20191223224700.jpg" alt></p><p>未来派运动与意大利的法西斯主义和墨索里尼有着紧密的联系，这就是为什么在报纸和海报设计中都可以看到未来派的图形艺术的原因。</p><p><img src="http://pic.drafff.art//drafff/20191223224647.jpg" alt="img"></p><p>达达主义是一种艺术运动，最初反映的是第一次世界大战。 他们从未来主义的实验性字体中大量借鉴，但他们的风格更为超现实。 他们反对艺术中的任何逻辑。 </p><p>在图形艺术中，他们将富有表现力的版式和对空白的极端使用与大量照片蒙太奇结合在一起。 字体本身所具有的象征意义与其所拼写的单词一样多。 这是1921年国际达达主义表演的海报。</p><p><img src="http://pic.drafff.art//drafff/20191223225141.jpg" alt></p><p>这是1919年Kurt Schwitters的《安娜·布鲁姆》的封面。</p><p><img src="http://pic.drafff.art//drafff/20191223225211.jpg" alt></p><p>荷兰风格派运动（或称荷兰风格）是在荷兰成立的抽象艺术运动。 凭借其严格的极简主义，荷兰风格派运动的艺术家将表达保持在最低限度，很少使用直线和原色以外的任何其他东西。 这里是著名画家彼得·蒙德里安（Piet Mondrian），他是荷兰风格派运动的主要人物之一。</p><p><img src="http://pic.drafff.art//drafff/20191223225451.jpg" alt></p><p>重要的是要注意的是，此处带有荷兰风格派运动出版物的原始徽标，这是形式和比例的极致使用。 这种形式和色彩的使用指向了Sol Lewitt的后期作品，甚至是计算机艺术的早期实验。 </p><p>所有这些运动对出版物中的版式、形式和颜色的使用方式产生了巨大的影响。 它拉近了高级艺术和印刷设计之间的距离，这三个运动对包豪斯主义有很大的影响。</p><hr><h2 id="包豪斯主义"><a href="#包豪斯主义" class="headerlink" title="包豪斯主义"></a>包豪斯主义</h2><p><img src="http://pic.drafff.art//drafff/20191223230514.jpg" alt></p><p>几乎没有什么东西可以影响现代建筑，艺术和设计，除了德国的包豪斯学校。 包豪斯学校由瓦尔特·格罗皮乌斯（Walter Gropius）于1919年在魏玛开设（图片是德绍包豪斯建筑群的所在地），它采用了现代主义的手法统一了艺术和手工艺。</p><p>包豪斯之所以成为可能，是因为工业革命的各种技术和机器可供所有人使用。</p><p><img src="http://pic.drafff.art//drafff/20191223230738.jpg" alt></p><p>包豪斯的基本座右铭是形式遵循功能，这意味着注重功能的简洁性：</p><blockquote><p>“就像在包豪斯的工作室中一样，最小的实用物体具有最简单的几何形状，它们也是最大的几何形状。因此，这里使人接受令人信服的均匀性的感觉是人为制造的所有物体大小，小到金属烟灰缸大到建筑物”</p><p>-Rudolf Arnheim</p></blockquote><p>因此，包豪斯时代的图形产品与包豪斯实践的所有其他艺术领域紧密相关。 没有功能含义就不会使用，这导致了对栅格和比例的更多关注。 色彩理论在包豪斯基础课程中也发挥了重要作用。</p><p><img src="http://pic.drafff.art//drafff/20191223231430.jpg" alt></p><p>一些重要的作品：</p><p><img src="http://pic.drafff.art//drafff/20191223231542.jpg" alt></p><p>瓦西里·康定斯基（Vassily Kandinsky）在他的画中使用了大量的几何形状。</p><p><img src="http://pic.drafff.art//drafff/20191223231705.jpg" alt></p><p>保罗·克莱（Paul Klee）通常被认为是画家，但他发表了许多设计相关论文（《形式与设计理论的文字》，英文为Paul Klees笔记本），突显了包豪斯艺术与手工艺结合的哲学。</p><p><img src="http://pic.drafff.art//drafff/20191223231809.jpg" alt></p><p>​    包豪斯对我们来说尤其重要是因为这个人，约翰内斯·伊滕（Johannes Itten）。伊滕是包豪斯大学基础课程的幕后推手之一，他以色彩理论方面的工作而闻名。</p><p>​    如果您想知道他为什么看起来如此怪异，那是因为他是基督教火教马兹达兹南（Mazdaznan）的追随者，在该教会中，成员严格遵守素食饮食，进行有规律的呼吸和体操锻炼。 这很重要，因为伊藤在色彩理论方面的工作与他的精神信念紧密相关。</p><p><img src="http://pic.drafff.art//drafff/20191223232206.jpg" alt></p><p>​    </p><p>伊滕（Itten）的著作《色彩的艺术》（The Art of Color）最为人所知。  在书中，他谈到了7种色彩对比，以及在艺术中使用色彩的一般方法。</p><p><img src="http://pic.drafff.art//drafff/20191223232250.jpg" alt></p><p>​    </p><p>​    曾是伊藤的学生的约瑟夫·阿尔伯斯（Josef Albers）也撰写了有关色彩理论的文章。 他一生中的大部分时间都花在创作这些形状和尺寸完全相同但颜色不同的画作。 他用它来观察颜色是如何相互作用的以及如何与表单进行交互。</p><p><img src="http://pic.drafff.art//drafff/20191223232435.jpg" alt></p><p>​    他写了《色彩的相互作用》这本书，这是初学者关于色彩理论的入门书籍。</p><p>​    他们两个都创建了颜色的分类方法。</p><p>​    阿尔伯斯（Albers）以及莫霍利·纳吉（Moholy-Nagy）都是最早进入美国的现代主义移民，在广告的黄金时代，他们都对新一代的美国平面设计师产生了深远的影响。 阿尔伯斯（Albers）被任命为耶鲁大学图形设计系主任，1937年莫霍利·纳吉（Moholy-Nagy）成为芝加哥新包豪斯学校的校长。</p><p><img src="http://pic.drafff.art//drafff/20191223232639.jpg" alt></p><p>​    即使大多数人都认为包豪斯是学习手工艺和建筑的地方，但它在图形设计上的造诣也不能低估。 正如您在包豪斯（Bauhaus）展览的海报中看到的那样，颜色，几何形状和版式在构图中的使用非常有趣，但严格遵循现代主义。 注意其中的直线，就像沃尔特·格罗皮乌斯（Walter Gropius）或勒·柯布西耶（Le Corbusier）的建筑一样。</p><p><img src="http://pic.drafff.art//drafff/20191223232750.jpg" alt></p><p>包豪斯在纳粹党的巨大压力下于1933年突然关闭。 包豪斯现代主义被纳粹主要政治人物认为是简朴的艺术，而现代主义则被古典主义理想所启发的艺术和建筑所取代。 这种新发现的浪漫现实主义是由希特勒的首席建筑师阿尔伯特·斯佩尔（Albert Speer）领导的。 纳粹党也对德国艺术作出了规定，尤其是希特勒和赖希马修·赫尔曼·戈林（二战结束时拥有人类已知的最大艺术收藏之一）。 在未来的几年中，平面设计在很大程度上受到全球政权变化的影响。</p><hr><h2 id="简·齐契霍尔德"><a href="#简·齐契霍尔德" class="headerlink" title="简·齐契霍尔德"></a>简·齐契霍尔德</h2><p>扬·施契霍尔德（Jan Tschichold）受到首届包豪斯魏玛（Bauhaus Weimar）展览的启发，于1928年发行了《 Die Neue Typografie》。今天被认为是印刷技术的极端现代主义宣言，对当时的图形设计和印刷术产生了深远的影响。</p><p>施契霍尔德在书中谴责了衬线字体以及居中设计的使用。 这本书可以看作是图形设计“瑞士风格”的手册。</p><p><img src="http://pic.drafff.art//drafff/20191223233746.jpg" alt></p><p>契克霍尔德与纳粹政权发生冲突，并与家人一起移居瑞士。 在1940年代，他搬到伦敦，在那里他为《企鹅》(Penguin Books)设计了手册，并帮助设计了500多本著名的企鹅平装书。</p><p><img src="http://pic.drafff.art//drafff/20191223233824.jpg" alt></p><p>这是1930年的Penguin Books平装本设计的一个示例，右边是契克霍尔德从1950年开始的修订版。</p><hr><h2 id="大创意设计师"><a href="#大创意设计师" class="headerlink" title="大创意设计师"></a>大创意设计师</h2><p>这些欧洲设计师影响了新一代的美国设计师，主要集中在50年代和60年代的纽约广告学院。 这些所谓的“大创意”设计师经常依靠单个设计师的创造力，将艺术家的思想引入主流广告中。</p><p>这些设计师以简约与好玩之间的平衡为特征，彻底改变了广告行业。 这个时期通常被称为广告的黄金时期，就像电视连续剧《狂人》中所颂扬的那样。</p><p><img src="http://pic.drafff.art//drafff/20191223234206.jpg" alt></p><p>威廉·伯恩巴赫（William Bernbach）的“think small”运动已经成为这些“大创意”设计师的首选例子。 重要的是要意识到这种广告与之前的广告截然不同。 它主要围绕单个设计师的想法，并且更加简约，大量使用空白，简单的排版和创造性的文本复制。</p><p>甲壳虫最初是为纳粹德国设计的大众汽车，因此，甲壳虫在美国市场上并没有取得明显的成功。 “think small”成功地在甲虫和美国消费者之间建立了牢固的关系。</p><p><img src="http://pic.drafff.art//drafff/20191223234612.jpg" alt></p><p>这是该广告系列的另一个示例。 俏皮和简单是广告中的全新内容。 还要注意在短标题末尾使用“.”。 那就是开始的地方。</p><p>威廉·伯恩巴赫（William Bernbach）绝对是担任独立艺术家的众多设计师之一：</p><blockquote><p>让我们向世界证明，好的品味，好的艺术和好的写作可以畅销。” </p><p>——威廉·伯恩巴赫</p></blockquote><p><img src="http://pic.drafff.art//drafff/20191223234810.jpg" alt></p><p>毫无疑问，Paul Rand是该领域历史上最有影响力的平面设计师之一。他以在IBM，NeXT和其他1000多家公司的徽标设计而闻名。</p><p><img src="http://pic.drafff.art//drafff/20191223234852.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191223234905.jpg" alt></p><p>兰德从史蒂夫·乔布斯（Steve Jobs）那收了设计该Logo的费用，10万美元。 故事是当兰德（Rand）展示Logo时，乔布斯（Jobs）的第一句话是：“我可以拥抱你吗？”。</p><p><img src="http://pic.drafff.art//drafff/20191223235216.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191223235302.jpg" alt></p><p>兰德也以对平面设计教育的评论而闻名。他辞去了耶鲁大学图形设计系主任一职，因为人们将后现代理论纳入课程。显然，后现代理论与他的现代主义思想发生了冲突。</p><p>兰德（Rand）也以他的许多书而著称，这些书帮助定义了实际的平面设计是什么：</p><blockquote><p><em>在集中主力思考之前， 你感觉到了你正在寻找东西， 你不知道自己在做什么，你迷路了，你在迷宫中。 因此，思考是设计过程中的第一要务。 设计是您思考的产物。</em></p><p><em>- Paul Rand</em></p><p>*另一种定义是设计是问题各个细节之间关系的系统，这意味着你与画布，橡皮擦与笔之间的关系。 元素比例之间的关系，即尺寸的关系。 我可以花以整天去推敲。 这就是设计如此难以完成的原因之一。 因为每次您做某事时，犯错的可能性是巨大的。 设计的过程从复杂到简单。</p><p><em>- Paul Rand</em></p></blockquote><p>保罗·兰德（Paul Rand）发行了许多书籍，他经常认为平面设计应着重于颜色、形式和比例，应被视为所有视觉艺术的基础。 广告已经成为一种艺术形式。</p><p><img src="http://pic.drafff.art//drafff/20191224000755.jpg" alt></p><p>此时期的另一位极为重要的设计师是索尔·巴斯（Saul Bass），他以电影海报设计而闻名。 后来他开始为电影制作标题序列，所有动画都带有剪纸动画。 这是“金臂男子”<em>(The Man with the Golden Arm)</em>的预告片。</p><p><a href="https://www.bilibili.com/video/av80447403/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80447403/</a></p><p>这是1960年的《 Psycho》预告片。</p><p><a href="https://www.bilibili.com/video/av80448403/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80448403/</a></p><hr><h2 id="瑞士风格"><a href="#瑞士风格" class="headerlink" title="瑞士风格"></a>瑞士风格</h2><p><img src="http://pic.drafff.art//brockmann-f61469505cb83f47c0e1500fe6506602_large.jpg" alt="brockmann-f61469505cb83f47c0e1500fe6506602_large"></p><p>​    瑞士风格是平面设计的新方法，它来自瑞士在1960年的平面设计的术语。这种方法主要围绕两本书：约瑟夫·穆勒·布罗克曼（JosefMüller-Brockmann）的<em>《网格系统》(Grid Systems)</em>和卡尔·格斯特纳（Karl Gerstner）的《设计程序》(Designing Programmes)*。</p><blockquote><p>这种图形的美学和方法是欧洲现代主义第二波影响美国的浪潮，其本质上与“大思想”方法不同，它基于现代主义理性“方法”的假设，这种方法不那么依赖于个人主义灵感和设计师的才华。</p><p>-“美国平面设计表达”，凯瑟琳·麦考伊，1990年</p></blockquote><p>​    瑞士风格提炼出平面设计的一系列约束和规则。使用Helvetica。使用网格系统。它以纯粹的功能性图形艺术的形式回归，正如<em>鲍豪斯（Bauhaus）</em>所描述的那样。如电影<em>Helvetica</em>的这段视频所述，<em>瑞士风格</em>对美国公司产生了深远的影响。</p><p>​    <strong>Josef Muller-Brockmann</strong>是一位极其重要的设计师，他的书网格系统》<em>(Grid Systems)</em>建议使用严格的网格系统来排序页面上的图形元素。</p><p><img src="http://pic.drafff.art//grid_systems-c10ae21ef8ef47d7101984f3f5590b1d_large.jpg" alt="grid_systems-c10ae21ef8ef47d7101984f3f5590b1d_large"></p><p>​    重要的是要意识到这种机械设计方式并不是每个人都喜欢的。失去了艺术家的艺术自由。作品很简单，但没有Paul Rand的作品的玩味。</p><p><img src="http://pic.drafff.art//brockmann2-6bc3c5c8d3b0490ae7471f6df102ec6d_large.jpg" alt="brockmann2-6bc3c5c8d3b0490ae7471f6df102ec6d_large"></p><p>​    ……几乎在任何与布罗克曼的访谈中都可以听到：</p><blockquote><p>“从最小的细节处着手，则该信息将具有最大的表达力。必须避免在夸张的意义上主观修饰和过分客观的表达。”</p><p>-JosefMüller-Brockmann</p></blockquote><p><img src="http://pic.drafff.art//designing_programmes-b1986c73a63e5e01c8a61b9c997bedd9_large.jpg" alt="designing_programmes-b1986c73a63e5e01c8a61b9c997bedd9_large"></p><p>​    在<em>设计程序中</em>，<strong>卡尔·格斯特纳</strong>（<strong>Karl Gerstner</strong>）甚至走得更远，并提出了一种基于严格模块化原理的图形设计方法。</p><p><img src="http://pic.drafff.art//gerstner-1397e436a7b74a23db25b6cc85410420_large.jpg" alt="gerstner-1397e436a7b74a23db25b6cc85410420_large"></p><p>​    从上图可以看出，Gerstner通常依赖可以重新用于生成设计的多个版本的规则。从这个意义上说，格斯特纳的工作几乎是算法上的。</p><p>​    在本课程中，重要的是这些瑞士设计师如何做出决定-与Big Idea设计师相反-视觉艺术如何在系统内工作与系统突破之间取得平衡。Gerstner的许多原理都可以直接移植到软件算法中，他的工作指向串行艺术（Serial Art）的概念，甚至是计算机艺术的早期实验。</p><h2 id="串口-Serial-艺术"><a href="#串口-Serial-艺术" class="headerlink" title="串口(Serial)艺术"></a>串口(Serial)艺术</h2><p>串口(Serial)艺术运动的各个方面可以追溯到1930年代，但随着卡尔·格斯特纳（Karl Gerstner）和索尔·莱维特（Sol Lewitt）等艺术家的出现，它在1960年代引起了公众关注。尽管计算机仍不是艺术家的工具，但串行艺术家的作品的核心是通过算法创建艺术的概念。</p><p>索尔·莱维特（Sol Lewitt）可能是最著名的串口(Serial)画家。他很有趣，因为他专注于视觉艺术背后的系统。对于Lewitt而言，真正的艺术作品是算法，而不是最终产品。</p><blockquote><p>该系统是艺术品。视觉艺术作品是系统的证明</p><p>-Sol Lewitt</p></blockquote><p>您可能从这些简单的算法生成的彩色作品中了解到了莱维特。</p><p><img src="http://pic.drafff.art//lewitt-dcefc4a7a529e3cab2e132763bc475d5_large.jpg" alt="lewitt-dcefc4a7a529e3cab2e132763bc475d5_large"></p><p>Lewitt以创建算法并让他的助手执行算法而闻名。他会通过手工绘制所有组合来为艺术品创建简单的规则。</p><p><img src="http://pic.drafff.art//lewitt_rules_hand-efdacbc1dda2718ae88a6be9a9cfeeac_large.jpg" alt="lewitt_rules_hand-efdacbc1dda2718ae88a6be9a9cfeeac_large"></p><p>然后将其转换为打印的规则表</p><p><img src="http://pic.drafff.art//drafff/20191224090139.jpg" alt></p><p>最后，规则将被翻译成雕塑或绘画，其中大部分由助手完成。</p><p><img src="http://pic.drafff.art//lewitt_cubes-8998ada8547857d731104a1b996b3bae_large.jpg" alt="lewitt_cubes-8998ada8547857d731104a1b996b3bae_large"></p><h2 id="计算机简史"><a href="#计算机简史" class="headerlink" title="计算机简史"></a>计算机简史</h2><p>这是谈论计算机的好时机。</p><p><img src="http://pic.drafff.art//sketchpad-dfef79202e8f770beda59879a471fc6c_large.jpg" alt="sketchpad-dfef79202e8f770beda59879a471fc6c_large"></p><p>第一个值得注意的计算机设计工具是由Ivan Sutherland于1963年制造的。它被称为Sketchpad，它是CAD绘图程序的早期形式。</p><p>用户可以使用光笔在屏幕上操纵几何形状。这很重要因为它是计算设计工具的第一个示例。</p><p><img src="http://pic.drafff.art//xerox-beanbags-37dc1bb5affae5fbbbb77b0226f28193_large.jpg" alt="xerox-beanbags-37dc1bb5affae5fbbbb77b0226f28193_large"></p><p>施乐PARC是一家成立于1971年的研究中心，隶属于施乐公司。它以其对计算机科学的贡献而闻名，其中包括UI，鼠标，激光打印机等。</p><p>这是斯坦福大学（后来的PARC）的道格拉斯·恩格尔巴特（Douglas Englebart）首次介绍计算机鼠标。</p><p><a href="https://www.bilibili.com/video/av80447888/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80447888/</a></p><p>重要的是要意识到一小部分人最终设计了我们今天都使用的所有基本的人机交互。从那以后，基本没有改变过。</p><p><img src="http://pic.drafff.art//xerox-star1-e4403d0ce54cf09376b4e44b76b8f73d_large.jpg" alt="xerox-star1-e4403d0ce54cf09376b4e44b76b8f73d_large"></p><p><img src="http://pic.drafff.art//xerox-star2-6b5b62499502f3dd1cb0dbba026be482_large.jpg" alt="xerox-star2-6b5b62499502f3dd1cb0dbba026be482_large"></p><p>注意这里的细节。通过不在背景中的深色像素顶部放置图标，图标的边缘将变得更加干净。</p><p><img src="http://pic.drafff.art//xerox-star3-f88c3caafb331a86dc366e4413c94580_large.jpg" alt="xerox-star3-f88c3caafb331a86dc366e4413c94580_large"></p><p>这是为您提供的信息图表！</p><p><img src="http://pic.drafff.art//googleui-f0df9c87353ac8cae68725e6f59a2345_large.jpg" alt="googleui-f0df9c87353ac8cae68725e6f59a2345_large"></p><p>​    以下是过去5年Google文档界面设计和1981年Xerox Star原始UI的比较。这应该使你对它们的成就有所了解。这也值得一提，伟大的设计是限制和约束的产物。</p><p>​    Xerox Parc的创作被证明具有极其重要的意义，这也是因为24岁的史蒂夫·乔布斯（Steve Jobs）参观了PARC设施，并受到启发为平面设计师创造了一些最重要的创新。</p><p>​    我想向你展示一个视频，不仅因为它非常有趣，关键是还能认识到史蒂夫·乔布斯为计算所做的工作：计算机突然成为一种创造力的工具。现在看来这很明显，但是那时并不这么觉得。</p><blockquote><p>Macintosh之所以表现出色，是因为从事此工作的人是音乐家，艺术家，诗人和历史学家，他们也恰好是出色的计算机科学家。</p><p>-史蒂夫·乔布斯</p></blockquote><p>他邀请了设计师参与进来！让这更多人可以用这些工具。</p><p><a href="https://www.bilibili.com/video/av80447749/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80447749/</a></p><p>计算机成为了创造的工具。</p><h2 id="第一台艺用计算机"><a href="#第一台艺用计算机" class="headerlink" title="第一台艺用计算机"></a>第一台艺用计算机</h2><p>就像包豪斯（Bauhaus）一样，普通人可以使用工业机器，而计算机也可以供艺术家使用。最早出现在南斯拉夫的名为<em>“新趋势”( New Tendencies )</em>运动的艺术家中，有些人与世界各地的艺术家见面。</p><p><img src="http://pic.drafff.art//nt1-8752c39d64ba58db873e615ce645e0fb_large.jpg" alt="nt1-8752c39d64ba58db873e615ce645e0fb_large"></p><p><em>“新趋势”( New Tendencies )</em> 在1960年代和1970年代的国际展览会和杂志“ Bit International”中探讨了计算机的使用。</p><p><img src="http://pic.drafff.art//nt2-86c369eed1ad4e5139a7c22bb6bfff02_large.jpg" alt="nt2-86c369eed1ad4e5139a7c22bb6bfff02_large"></p><p>这是1962年在巴黎举行的聚会的照片。</p><p><img src="http://pic.drafff.art//drafff/20191224092930.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224093001.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224093013.jpg" alt></p><p>卡尔·赖因哈茨（Karl Reinhartz），1962年</p><p><img src="http://pic.drafff.art//drafff/20191224093039.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224093052.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224093108.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224093128.jpg" alt></p><p>何塞·玛丽亚·伊图拉尔德（Jose Maria Yturralde），1972年</p><p><img src="http://pic.drafff.art//drafff/20191224093234.jpg" alt></p><p>曼努埃尔·巴巴迪林（Manuel Barbadilloin）,1973</p><p>计算艺术的另一个重要里程碑是1965年在MoMa举行的<em>“响应之眼”(The Reponsive Eye)</em>展览。该展览以所谓的“光学艺术”的最新发展为特色。许多艺术家使用计算机来创作作品。</p><p><img src="http://pic.drafff.art//drafff/20191224093418.jpg" alt></p><p>约瑟夫·阿尔伯斯（Josef Albers）在展览中展示了作品。</p><p><img src="http://pic.drafff.art//drafff/20191224093511.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224093531.jpg" alt></p><h2 id="第二代计算艺术家"><a href="#第二代计算艺术家" class="headerlink" title="第二代计算艺术家"></a>第二代计算艺术家</h2><p>第二代艺术家始于1980年代和1990年代。他们的共同特点是对编程艺术的深入了解和关注。</p><p><img src="http://pic.drafff.art//drafff/20191224104833.jpg" alt></p><p>约翰·前田（John Maeda）撰写了颇有影响力的书籍“数字设计”<em>(Design by Numbers)</em>，“创意代码”<em>(Creative Code)</em>和“前田＆媒体”<em>(Maeda&amp;Media)</em>。 他是麻省理工学院美学与计算小组的负责人，并且是Ben Fry和Casey Reas以及ITP的Jared Shiffman的老师。</p><p><img src="http://pic.drafff.art//drafff/20191224095301.jpg" alt></p><p>马克·威尔逊（Mark Wilson）以绘图仪绘图的实验而闻名。 他在1992年获得了Ars Electronica大奖，尽管他最早的作品还早于hom-computer-graphics，但他的风格却与1990年代的美学非常相似。</p><p><img src="http://pic.drafff.art//drafff/20191224095413.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224095515.jpg" alt></p><p>卡尔·西姆斯（Karl Sims）以其进化的图形艺术而著称（例如加拉帕戈斯装置）。 他经常在计算机程序中使用粒子系统和人造生命来产生最终输出。 索尔·莱维特（Sol Lewitt）的说明与卡尔·西姆斯（Karl Sims）的软件（在输出中选择其内容）之间存在有趣的联系。</p><h2 id="互联网和设计程序作为编程环境"><a href="#互联网和设计程序作为编程环境" class="headerlink" title="互联网和设计程序作为编程环境"></a>互联网和设计程序作为编程环境</h2><p>没有什么比互联网能更快地促进新编程艺术家的发展了。一系列的编程环境开始吸引设计师，不然他们也就不会将编程视为一种创造性的表达。</p><p><img src="http://pic.drafff.art//drafff/20191224095752.jpg" alt></p><p>这是Internet和HTML + CSS（虽然不是编程语言）。</p><p><img src="http://pic.drafff.art//drafff/20191224095906.jpg" alt></p><p>Adobe Director和编程语言Lingo。第一次可以在屏幕上绘制内容并用代码控制它们。虽然很基础。</p><p><img src="http://pic.drafff.art//drafff/20191224095939.jpg" alt></p><p>尽管表现不佳，Flash在图形设计师方面还是非常成功的。 绘制对象并在代码（DisplayObject和场景图）中进行操作的概念非常新颖，并且启发了许多现代框架。</p><p><img src="http://pic.drafff.art//drafff/20191224100031.jpg" alt></p><p>有关Flash和Director的书籍开始出版，但仅针对设计师。 然而，有趣的是，所有这些书都集中在生成艺术上，而不是平面设计上。 在书的封面上使用<em>网名(hacker name )</em>仍然是一件很时髦的事情。</p><p><img src="http://pic.drafff.art//drafff/20191224100149.jpg" alt></p><p>当然还有Processing！</p><p><img src="http://pic.drafff.art//drafff/20191224100306.png" alt></p><h2 id="如今"><a href="#如今" class="headerlink" title="如今"></a>如今</h2><p>鉴于图形设计系统的悠久历史，本课程将探讨平面设计和编程的交汇点。 这里有一些在这个领域工作的设计师的例子。</p><h3 id="E-Roon-Kang"><a href="#E-Roon-Kang" class="headerlink" title="E. Roon Kang"></a>E. Roon Kang</h3><p>由Processing生成的MITLogo。用于在线浏览和打印。我们将在Logo类中详细讨论这一点。</p><p><img src="http://pic.drafff.art//drafff/20191224100541.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224100551.jpg" alt></p><p>图形系统。</p><p><img src="http://pic.drafff.art//drafff/20191224100627.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224100635.jpg" alt></p><h3 id="Sagmeister-amp-Walsh"><a href="#Sagmeister-amp-Walsh" class="headerlink" title="Sagmeister &amp; Walsh"></a>Sagmeister &amp; Walsh</h3><p>美是功能的一部分。Logo是系统化字体，图案。</p><p><img src="http://pic.drafff.art//drafff/20191224100755.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224100812.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224100823.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224100849.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224100858.jpg" alt></p><h3 id="Stewart-Smith"><a href="#Stewart-Smith" class="headerlink" title="Stewart Smith"></a>Stewart Smith</h3><p>从这开始…</p><p><img src="http://pic.drafff.art//drafff/20191224100947.jpg" alt></p><p><img src="http://pic.drafff.art//drafff/20191224101000.jpg" alt></p><p>到这…</p><p><a href="https://www.bilibili.com/video/av80447749/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80447749/</a></p><h3 id="Jonathan-Puckey"><a href="#Jonathan-Puckey" class="headerlink" title="Jonathan Puckey"></a>Jonathan Puckey</h3><p><img src="http://pic.drafff.art//drafff/20191224101037.jpg" alt></p><h3 id="Karsten-Schmidt"><a href="#Karsten-Schmidt" class="headerlink" title="Karsten Schmidt"></a>Karsten Schmidt</h3><p><img src="http://pic.drafff.art//drafff/20191224101103.jpg" alt></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这是印刷书籍中代码自动化的一些示例。</p><p><img src="http://pic.drafff.art//drafff/20191224101201.jpg" alt></p><p><a href="https://www.bilibili.com/video/av80444293/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80444293/</a></p><p><img src="http://pic.drafff.art//drafff/20191224101224.jpg" alt></p><p><a href="https://www.bilibili.com/video/av80444293/" target="_blank" rel="noopener">https://www.bilibili.com/video/av80444293/</a></p><p><img src="http://pic.drafff.art//drafff/20191224101233.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们不是在盲目的创作。在我们之前有一整个关于平面设计和计算机图形设计的历史。</p><p>对我们来说，在开始创作之前了解这些历史非常重要。 因为我们是在编程，并不意味着我们发明了新的东西。 人们从事图形艺术已有数百年历史，了解这些东西很重要。 我们可以改变规则，但不能忽略它们。 为了使它们改变，我们必须了解它们。</p><p>希望在这堂课中，你将学会以某种方式平衡你的视觉创造力和技术技能，以便互相优化。 我认为在生成艺术方面几乎没有人能做到这一点。 这与通过重复算法涂抹画布不同。 要学会如何使用计算机的优点，而不是在画布上随机放置一堆东西。 思考！</p><p>本文译自<a href="http://printingcode.runemadsen.com/lecture-intro" target="_blank" rel="noopener">A HISTORY OF DESIGN SYSTEMS</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.简介 #Programming Design System</title>
      <link href="/2020/1-%E7%AE%80%E4%BB%8B-Programming-Design-System/"/>
      <url>/2020/1-%E7%AE%80%E4%BB%8B-Programming-Design-System/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们如今正处于一个从‘面向对象’向‘面向系统’的过度时期。变化没有发生在事务本身上，而是在事务完成的方法上。</p><p>Jack Burnham (1968), Systems Esthetics</p></blockquote><p>​    如果我让你定义一下平面设计师扮演的角色，会是怎样的？这个问题会有各种各样的答案，但我的定义是：平面设计师是一个通过形状和颜色来传达一段内容的人。这项工作可以有很多形式，但目前为止，它主要包括了海报，名片，书籍封面等形式的印刷品。</p><p>​    我们面临着新的挑战，不是因为设计的定义发生了巨大的改变，而是我们需要生产的产品已经变了。我们如今把大部分的时间花在电子屏幕而不是纸上，于是对能够为数字设备做设计的设计师产生了极大的需求。但是数字产品不像印刷品。数字产品需要把动态的内容显示在不同尺寸的设备上。数字产品能让用户与内容交互，并从动态效果中获取有用的信息。<strong>此外，数字产品通常具有时间逻辑，其中的线性叙事被复杂的状态和转换替代了。</strong> <em>(Furthermore, digital products often have temporal logic where a linear narrative is replaced by a set of complex states and transitions. )</em> 但是归根结底，数字产品都有同一个特征：都是通过编程语言创作的。</p><p>​    对于根植于<strong>纯艺</strong>  <em>(fine arts)</em> 的领域来说，这将是一个非常困难的转变。许多平面设计的学校都采取了<strong>瀑布式的教学方法</strong> <em>(waterfall philosophy)</em>，学生们把自己定位成能够为他人提供构想的创意者。毕竟，这比采取一个全新的教学方式简单多了。但是，这种方法的根本问题在于传统的静态设计工具（例如illustrator和sketch）无法胜任数字系统的原型制作。即使实在<strong>页面隐喻</strong> <em>(metaphor)</em>任然盛行的网页设计中，它们似乎也只能局限于设计网页的外观。谷歌会只是因为有一个好看的搜索框而成为一个优秀的网站吗？传统的平面设计固然非常重要，这本书也是构建在传统平面设计基础上的。然而设计领域和新兴技术之间已经有了长达一个世纪的纽带，如果平面设计师不习惯于这些新的<strong>数字现实</strong> <em>(digital reality)</em>，那么就会被时代淘汰。如今我们有了编写生成精美设计作品代码的能力，<strong>而未来的设计师必须了解如何实现这个承诺</strong>。 <em>(and the designer of tomorrow will have to understand how to deliver on that promise.)</em></p><p>​    当我们试图通过把一门编程语言当作设计师的工具来重定义平面设计课程时会发生什么？这本书给出了一个简单的答案。有很多理由来说明为什么这是一个强有力的概念。首先，平面设计师经常在他们工作中使用<strong>设计系统</strong> <em>(systems)</em>。我们使用栅格系统来平衡我们的排版，使用色环来选择<strong>合适的颜色</strong> <em>(colors with proper distance to each other)</em>。历史告诉我们<strong>设计系统</strong>能够使我们克服对空白画布的恐惧。将这些系统的概念应用到代码里将会是一个<strong>很有力的概念</strong> (powerful concept)。其次，代码能使设计师做一些之前做不到的事情。在原型设计阶段，设计中的变化可以更迅速地被测试，并且可以使用随机函数生成设计师永远也无法通过铅笔达到的效果。第三，它使设计师创建能够根据时间、地点或者用途而变化的动态系统。把设计作品扔在墙上不管不顾，仅仅是看，使印刷作品遗留下来的不良习惯，没有理由使设计的过程伴随着作品的诞生而结束。</p><p>​    这本书的结构类似于对平面设计的介绍，着重于视觉设计的元素以及它们与算法设计的关系。这本书是写给想要成为更好程序员的设计师和想成为更好设计师的程序员。在你阅读此书时，你会发现它从最基础的内容开始。代码将会非常简单，练习也会限制在合理的范围。如果觉得这本书很简单，请继续往下读。这些基础概念是为某些复杂的概念奠定基础的，我们很快就会接触到更具挑战性的主题。在本书的最后，我希望你能学习到两个新技能：如何使用代码创建新颖有趣的平面设计作品，以及如何评估这些设计是否成功。</p><p>​    我决定本书中的所有实例都使用<a href="https://p5js.org/" target="_blank" rel="noopener">P5.js这个JavaScript库</a> 。它已经被证明对于初学者来说是一个很好的编程环境，同时对于高级用户来说，它也足够强大。我知道，不可能选择一种适合所有人的编程语言，并且读者可能需要根据具体项目的性质，将本书中的思想移植到其他编程语言和框架中。因此，我试图将文字写得尽可能概括。同样重要的是，要注意这不是一本关于网页设计的书。尽管这些示例可以嵌入到任何网页上，但是这些技术可以同时应用于数字和印刷作品。实际上，我已经看到我的学生创造了各种各样的设计作品，包括雕塑，绘画，时装，摄影，游戏设计，网页设计和印刷品等项目。</p><p>​    这本书是为具有JavaScript编程入门知识的读者而写的，这意味着几乎没有时间花在解释变量，函数和循环等概念上。对于没有基础的读者，我强烈推荐Daniel Shiffman的<a href="https://www.youtube.com/playlist?list=PLRqwX-V7Uu6Zy51Q-x9tMWIv9cueOFTFA" target="_blank" rel="noopener">Coding Rainbow YouTube YouTube</a>频道，Dan在解释这些概念方面做得比我做得更好。这些视频还将介绍P5.js中编程的基本概念。</p><p>​    我不是第一个写有关平面设计系统的作者，这本书使用了许多令人难以置信的作者的想法，这些作者多到在这里无法一一提及。 我也不是第一个写编程和平面设计的人，但是我对这个领域的书籍感到沮丧，这些书大致分为两类：那些专注于代码和生成设计的书，却没有讲授平面设计原理。 那些做出优秀设计作品的书，却没有总结项目的制作方式或成功的原因。 所以需要一本以现代的方式讲授平面设计的基础的教学材料，特别是如果它还能为学生提供用于批判数字设计项目的心理模型。</p><p>​    我选择在没有出版商的情况下免费在线出版这本书。 这样做的主要原因是自由。 它使我能够编写和设计我想要的书籍类型。 这反映在本书的结构中，该书的结构包括许多较短的章节，这些章节在网络上更易于阅读，并且教师可以直接改编以用于教学（由于拥有知识共享许可，因此完全合法）。 我将以非线性方式撰写这些章节，讨论我在特定时间最感兴趣的主题。 尽管我将其作为全职工作，但没有完成本书的具体截止日期。 本书的源代码可在GitHub上找到，我鼓励所有读者<strong>提交问题</strong> <em>(issues)</em>或提出<strong>修改请求</strong> <em>(pull requests)</em>。 要了解本书的最新进展，可以在网站上通过邮箱订阅。</p><p>​    我要感谢下面这些人，没有他们就没有这本书。当我2009年移居纽约，在纽约大学的“互动电信计划”（ITP）学习时，我只有一个模糊的想法，就是想在艺术与代码的交汇处创作。作为主要开发横幅广告的Flash开发人员，在ITP的两年时间完全改变了我的想法。我要感谢Dan O’Sullivan对这个项目的大力支持，该项目始于ITP的一个班级，在我担任研究人员的同时它经发展成为一本书。没有Daniel Shiffman的帮助和指导，这本书就不会存在。Daniel Shiffman的工作启发了成千上万的学生学习代码。我还要感谢斯图尔特·史密斯（Stewart Smith），他在“可视化数据”课上讲授了本书的早期构想。我感谢所有帮助塑造这些想法的ITP教师和校友，包括Patrick Hebron，Greg Borenstein，Clay Shirky，Danny Rozin，Tom Igoe，David Nolen，Gabe Barcia-Colombo和George Agudow。特别感谢P5.js的原始作者Lauren McCarthy，以及Casey Reas和Ben Fry在Processing方面的工作。我要感谢钱德勒·亚伯拉罕（Chandler Abraham）在色彩空间一章中所做的详细编辑，克莱尔·科尼·沃尔普（Claire Kearney-Volpe）回答了我有关可访问性的众多问题，以及玛丽亚·玛格瓦德·詹森（Maria Marqvard Jensen）的不懈努力。现在，我们开始吧。</p><p>本文译自<a href="https://programmingdesignsystems.com/" target="_blank" rel="noopener">Programming Design Systems</a></p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程设计系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转载）为什么把编程当作自学的入口？</title>
      <link href="/2020/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E7%BC%96%E7%A8%8B%E5%BD%93%E4%BD%9C%E8%87%AA%E5%AD%A6%E7%9A%84%E5%85%A5%E5%8F%A3%EF%BC%9F/"/>
      <url>/2020/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E7%BC%96%E7%A8%8B%E5%BD%93%E4%BD%9C%E8%87%AA%E5%AD%A6%E7%9A%84%E5%85%A5%E5%8F%A3%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>本文来自<a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">《自学的手艺》</a>李笑来</p><p>很多人误以为 “编程” 是很难的事情。</p><p>…… 实则不然 —— 这恰恰是我们选择 “编程” 作为自学的第一个 “执行项目” 的原因。</p><p>一本关于自学能力的书，若是真的能够起到作用，那么它就必须让读者在读之前和读之后不一样 —— 比如，之前可能没有自学能力，或者自学能力很差，之后就有了一定的自学能力……</p><p>然而，这很难。不但对读者来说很难，对作者来说更难 —— 我当过那么多年被学生高度评价的老师，出版过若干本畅销且长销的书籍，所以更是清楚地知道例子的重要性。</p><p>道理当然很重要；可是，在传递道理的时候，例子相对来看好像更重要。</p><p>同样的道理，例子不准，人就可能会理解错；例子不精彩，人就可能听不进去；例子居然可以令人震惊，那就可以做到让听众、让读者 “永生不忘”。</p><p>许多年前，有位后来在美国读书已经博士毕业了的学生来信，大意是说：</p><blockquote><p>好多年前，我在新东方上课，听您讲，人学习就好像是动物进化一样…… 很多人很早就开始停止了进化，本质上跟猴子没啥区别。</p><p>那段类比好长，我记不太清楚细节了…… 可是，当时我是出了一身汗的，因为我忽然觉得自己是一只猴子。可是，突然之间，我不想继续做猴子，更不想一直做猴子！</p><p>从那之后，我好像变了一个人似的…… 现在我已经博士毕业了，觉得应该写封信告诉您，我不再是猴子了，最起码是大猩猩，而且我保证，我会一直进化。</p><p>……</p></blockquote><p>所以啊，在我看来，写书讲课之前，最重要的工作，也是做得最多的事情，其实就是 “找到好例子” —— 那即意味着说，先要找到很多很多恰当合适的例子，而后再通过反复比较试验，挑出那个效果最好的例子。了解了这一点，将来你准备任何演讲，都会不由自主地多花一点时间在这方面，效果肯定比 “把幻灯片做得更花哨一些” 要好太多了罢？</p><p>后来，我选中了一个例子：“<strong>自学编程</strong>” —— “<em>尽量只通过阅读学会编程</em>”。</p><h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h2><p>选择它的理由，首先就在于：</p><blockquote><p>事实证明，<strong>它就是无论是谁都能学会的</strong> —— 千万别不信。</p></blockquote><p>它老少皆宜 —— 也就是说，“只要你愿意”，根本没有年龄差异。十二岁的孩子可以学；十八岁的大学生可以学；在职工作人员可以学…… 就算你已经退休了，想学就能学，谁也拦不住你。</p><p>它也不分性别，男性可以学，女性同样可以学，性别差异在这里完全不存在。</p><p>它也不分国界，更没有区域差异 —— 互联网的恩惠在于，你在北京、纽约也好，老头沟、门头沟也罢，在这个领域里同样完全没有任何具体差异。</p><p>尤其是在中国。现状是，中国的人口密度极高，优质教育资源的确就是稀缺…… 但在计算机科学领域，所有的所谓 “优质教育资源” 事实上完全没有任何独特的竞争力 —— 编程领域，实际上是当今世上极为罕见的 “<strong>教育机会公平之地</strong>”。又不仅在中国如此，事实上，在全球范围内也都是如此。</p><h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h2><p>编程作为 “讲解如何习得自学能力的例子”，实在是太好了。</p><p>首先，编程这个东西反正要自学 —— 不信你问问计算机专业的人，他们会如实告诉你的，学校里确实也教，但说实话都教得不太好……</p><p>其次，编程这个东西最适合 “仅靠阅读自学” —— 这个领域发展很快，到最后，新东西出来的时候，没有老师存在，任由你是谁，都只能去阅读 “官方文档”，只此一条路。</p><p>然后，也是最重要的一条，别管是不是很多人觉得编程是很难的东西，事实上它就是每个人都应该具备的技能。</p><p>许多年前，不识字，被称为文盲……</p><p>后来，人们反应过来了，不识英文，也是文盲，因为科学文献的主导语言是英文，读不懂英文，什么都吃不上热乎的；等菜好不容易端上来了吧，早就凉了不说，味道都常常会变……</p><p>再后来，不懂基本计算机操作技能的，也算是文盲，因为他们无论做什么事情，效率都太低下了，明明可以用快捷键一下子完成的事情，却非要手动大量重复……</p><p>到了最近，不懂数据分析的，也开始算作文盲了。许多年前人们惊呼信息时代来了的时候，其实暂时体会不到什么太多的不同。然而，许多年过去，互联网上的格式化数据越来越多，不仅如此，实时产出的格式化数据也越来越多，于是，数据分析不仅成了必备的能力，而且早就开始直接影响一个人的薪资水平。</p><p>你作为一个个体，每天都在产生各种各样的数据，然后时时刻刻都在被别人使用着、分析着…… 然而你自己却全然没有数据分析能力，甚至不知道这事很重要，是不是感觉很可怕？你看看周边那么多人，有多大的比例想过这事？反正那些天天看机器算法生成的信息流的人好像就是全然不在意自己正在被支配……</p><p>怎么办？学呗，学点编程罢 —— 巧了，<em>这还真是个正常人都能学会的技能</em>。</p><h2 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h2><p>编程作为 “讲解如何习得自学能力的例子” 最好的地方在于，这个领域的知识结构，最接近每个人所面对的人生中的知识结构。</p><p>这是什么意思呢？</p><p>编程入门的门槛之所以高，有个比较特殊的原因：</p><blockquote><p><strong>它的知识点结构不是线性的</strong>。</p></blockquote><p>我们在中小学里所遇到的教科书，其中每个章节所涉及到的知识点之间，全都是线性关联。第一章学好了，就有基础学第二章；在第二章的概念不会出现在第一章之中……</p><p>很遗憾，编程所涉及到的知识点没办法这样组织 —— 就是不行。编程教材之所以难以读懂，就是因为它的各章中的知识点结构不是线性排列的。你经常在某一章读到不知道后面第几章才可能讲解清楚的概念。</p><p>比如，几乎所有的 Python 编程书籍上来就举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello, world!'</span>)</span><br></pre></td></tr></table></figure><p>姑且不管这个例子是否意义非凡或者意义莫名，关键在于，<code>print()</code> 是个函数，而函数这个概念，不可能一上来就讲清楚，只能在后面若干章之后才开始讲解……</p><blockquote><p>想要理解当前的知识点，需要依赖对以后才能开始学习的某个甚至多个知识点的深入了解……</p></blockquote><p>这种现象，可以借用一个专门的英文概念，叫做 “<strong>Forward References</strong>” —— 原本是计算机领域里的一个<a href="https://en.wikipedia.org/wiki/Forward_declaration" target="_blank" rel="noopener">术语</a>。为了配合当前的语境，姑且把它翻译为 “<strong>过早引用</strong>” 罢，或者 “<strong>前置引用</strong>” 也行。</p><p>学校里的课本，都很严谨 —— 任何概念，未经声明就禁止使用。所以，学完一章，就能学下一章；跳到某一章遇到不熟悉的概念，往前翻肯定能找到……</p><p>在学校里习惯了这种知识体系的人，离开学校之后马上抓瞎 —— <strong>社会的知识结构不仅不是这样的，而且*几乎全都不是*这样的</strong>。工作中、生活里，充满了各式各样的 “<em>过早引用</em>”。为什么总是要到多年以后你才明白父母曾经说过的话那么有道理？为什么总要到孩子已经长大之后才反应过来当初自己对孩子做错过很多事情？为什么在自己成为领导之前总是以为他们只不过是在忽悠你？为什么那么多人创业失败了之后才反应过来当初投资人提醒的一些观念其实是千真万确的？—— 因为很多概念很多观念是 “过早引用”，在当时就是非常难以理解……</p><p>自学编程在这方面的好处在于，在自学的过程中，其实你相当于过了一遍 “模拟人生” —— 于是，面对同样的 “<em>过早引用</em>”，你不会觉得那么莫名其妙，你有一套你早已在 “模拟人生” 中练就的方法论去应对。</p><h2 id="（四）"><a href="#（四）" class="headerlink" title="（四）"></a>（四）</h2><p>另外一个把编程作为 “讲解如何习得自学能力的例子” 最好的地方在于，你在这个过程中将不得不习得英语 —— 起码是英文阅读能力，它能让你在不知不觉中 “脱盲”。</p><p>学编程中最重要的活动就是 “阅读官方文档”。学 Python 更是如此。Python 有很多非常优秀的地方，其中一个令人无法忽视的优点就是它的文档完善程度极好。它甚至有专门的文档生成工具，<a href="http://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">Sphinx</a>：</p><blockquote><p>Sphinx is a tool that makes it easy to create intelligent and beautiful documentation, written by Georg Brandl and licensed under the BSD license.</p><p>It was originally created for <a href="https://docs.python.org/" target="_blank" rel="noopener">the Python documentation</a>, and it has excellent facilities for the documentation of software projects in a range of languages. Of course, this site is also created from reStructuredText sources using Sphinx!</p></blockquote><p>最好的 Python 教程，是官方网站上的 <a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a>，读它就够了。我个人完全没兴趣从头到尾写一本 Python 编程教材，不仅因为人家写得真好，而且它就放在那里。</p><p>虽然你在官方网站上就是很难找到它的中文版，虽然就不告诉你到底在哪里也显得很不厚道，但是，我建议你就只看英文版 —— 因为离开了这个教程之后，还是要面对绝大多数都是英文的现实。</p><p>为了照顾那些也想读完本书，但因为种种原因想着读中文可以快一些的人，链接还是放在这里：</p><blockquote><ul><li><a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/tutorial/index.html</a> (for v.3.7.2）</li><li><a href="http://www.pythondoc.com/pythontutorial3/" target="_blank" rel="noopener">http://www.pythondoc.com/pythontutorial3/</a> (for v.3.6.3)</li></ul></blockquote><p>我曾经专门写过一本书发布在网上，叫《<a href="https://github.com/xiaolai/everyone-can-use-english" target="_blank" rel="noopener">人人都能用英语</a>》。其中的观点就是，大多数人之所以在英语这事上很矬，是因为他们花无数的时间去 <em>“学”</em>，但就是 <em>“不用”</em>。学以致用，用以促学。可就是不用，无论如何就是不用，那英语学了那么多年能学好吗？</p><p>自学编程的一个 “副作用” 就是，<strong>你不得不用英语</strong>。而且还是天天用，不停地用。</p><p>当年我上大学的时候，最初英语当然也不好。不过，因为想读当时还是禁书的《动物庄园》（<a href="https://www.marxists.org/subject/art/literature/children/texts/orwell/animal-farm/index.htm" target="_blank" rel="noopener">Animal Farm</a>），就只好看原版（当时好不容易搞到的是本英法对照版）…… 然后英语阅读就基本过关了。</p><p>这原理大抵上是这样，刚开始，英语就好像一层毛玻璃，隔在你和你很想要了解的内容之间。然而，由于你对那内容的兴趣和需求是如此强烈，乃至于即便隔着毛玻璃你也会挣扎着去看清楚…… 挣扎久了（其实没两天就不一样），你的 “视力” 就进化了，毛玻璃还在那里，但你好像可以穿透它看清一切……</p><p>自学编程，也算是一举两得了！</p><h2 id="（五）"><a href="#（五）" class="headerlink" title="（五）"></a>（五）</h2><p>当然，把编程作为 “讲解如何习得自学能力的例子”，实在是太好了的最重要原因在于，自学编程对任何人来说都绝对是：</p><blockquote><ul><li>现实的（Practical）</li><li>可行动的（Actionable）</li><li>并且还是真正是可达成的（Achievable）</li></ul></blockquote><p>最重要的就是最后这个 “可达成的”。虽然对读者和作者来说，一个做到没那么容易，另一个讲清楚也非常难，但是，既然是所有人都 “可达成的”，总得试试吧？但是，请相信我，这事比减肥容易多了 —— 毕竟，你不是在跟基因作斗争。</p><p>这只是个起点。</p><p>尽量只靠阅读学会编程，哪怕仅仅是入门，这个经历和经验都是极为宝贵的。</p><p>自学是门手艺。只不过它并不像卖油翁的手艺那样很容易被别人看到，也不是很容易拿它出来炫耀 —— 因为别人看不到么！然而，经年累月，就不一样了，那好处管他别人知不知道，自己却清楚得很！</p><p>你身边总有些人能把别人做不好的事做得极好，你一定很羡慕。可他们为什么能做到那样呢？很简单啊，他们的自学能力强，所以他们能学会大多数自学能力差的人终生学不到的东西。而且他们的自学能力会越来越强，每学会一样新东西，他们就积累了更多自学经验，难以对外言表的经验，再遇到什么新东西，相对没那么吃力。</p><p>另外，自学者最大的感受就是万物相通。他们经常说的话有这么一句：“…… <strong>到最后，都是一样的呢</strong>。”</p><h2 id="（六）"><a href="#（六）" class="headerlink" title="（六）"></a>（六）</h2><p>最后一个好处，一句话就能说清楚，并且，随着时间的推移，你对此的感触会越来越深：</p><blockquote><p>在这个领域里，自学的人最多……</p></blockquote><p>没有什么比这句话更令人舒心的了：<strong>相信我，你并不孤独</strong>。</p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a></p><p>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A-B-O-U-T</title>
      <link href="/2020/A-B-O-U-T/"/>
      <url>/2020/A-B-O-U-T/</url>
      
        <content type="html"><![CDATA[<p>sdfsdf</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>W-H-I-T-E-H-O-L-E</title>
      <link href="/2020/W-H-I-T-E-H-O-L-E/"/>
      <url>/2020/W-H-I-T-E-H-O-L-E/</url>
      
        <content type="html"><![CDATA[<iframe src="http://something.drafff.art/whitehole" width="400" height="400"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>santa</title>
      <link href="/2019/santa/"/>
      <url>/2019/santa/</url>
      
        <content type="html"><![CDATA[<button onclick="setC2()">Copy Text</button><script type="text/javascript">function setC1(){    background(220);    colors = [ '#f8b195', '#f67280', '#c06c84', '#6c567b'];}function setC2(){    background(220);    colors = [ '#464159', '#6c7b95', '#8bbabb', '#c7f0db'];}function setC3(){    background(220);    colors = [ '#35477d', '#6c5b7b', '#c06c84', '#f67280'];}function setC4(){    background(220);    colors = [ '#2d334a', '#0c9463', '#fab696', '#fbe3b9'];}<div id="p5container"></div>let symmetry = 12;let angle = 360 / symmetry;function setup() {    let myCanvas = createCanvas(600, 400);    myCanvas.parent("p5container");    angleMode(DEGREES);    background(220);}function draw() {    translate(width / 2, height / 2);    let mx = mouseX - width / 2;    let my = mouseY - height / 2;    let pmx = pmouseX - height / 2;    let pmy = pmouseY - height / 2;    if (mouseIsPressed) {        let c = getCol();        stroke(getCol());        strokeWeight(4);        for (let i = 0; i < 12; i++) {            rotate(angle);            let d = dist(mx, my, pmx, pmy);            let sw = map(d, 0, 20, 20, 1);            strokeWeight(sw);            line(mx, my, pmx, pmy);        }    }}let colors = [ '#404040'];function getCol() {    return colors[int(random(colors.length))];}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>E Y E</title>
      <link href="/2019/E-Y-E/"/>
      <url>/2019/E-Y-E/</url>
      
        <content type="html"><![CDATA[<p>当你凝视深渊的时候深渊也在凝视你。</p><div id="container" style="width:400px"></div><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;let cell = ww / 10;function setup() {    var myCanvas = createCanvas(ww,ww);    myCanvas.parent("container");    background(0);    rectMode(CENTER);    colorMode(HSB, 360, 100, 100);}function draw() {  for (let x = cell; x < ww; x += cell) {    for (let y = cell; y < ww; y += cell) {      if ((x > cell*6 || x < cell*4) || (y < cell*4 || cell*4)) {        stroke(random(360), 100, 100);        fill(random(360), random(100), random(100));        ellipse(x, y, random(cell), random(cell));      }    }  }}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B A I N A N Z H U N</title>
      <link href="/2019/B%20A%20I%20N%20A%20N%20Z%20H%20U%20N/"/>
      <url>/2019/B%20A%20I%20N%20A%20N%20Z%20H%20U%20N/</url>
      
        <content type="html"><![CDATA[<h1 id="白南准"><a href="#白南准" class="headerlink" title="白南准"></a>白南准</h1><p>Nam June Paik</p><p>不是制造另一个科学玩具，而是将科技和电子媒介人性化</p><p><img src="https://i.imgur.com/5eVTaHe.jpg" alt="KnWnOZHtvlBD_2400x2400"></p><font size="3" color="#888888">Nam June Paik in Miami, c. 1990. Photo: Brian Smit</font><h1 id="“"><a href="#“" class="headerlink" title="“"></a>“</h1><p>我的电视既非从始至终是有趣的，<br>亦非从始至终是无趣的；<br>就像大自然是美丽的，<br>并非因它在美丽地变化，<br>仅仅因为它是变化的。</p><h1 id="”"><a href="#”" class="headerlink" title="”"></a>”</h1><!-- ## 影像艺术先锋 --><p><img src="https://i.loli.net/2019/03/15/5c8b6b63da587.png" alt="小标题"></p><p>对于白南准（Nam June Paik）这个名字大多数人会觉得陌生，但是他的作品大多数人都在教材中见过。</p><h3 id="TV-Buddha-电视佛"><a href="#TV-Buddha-电视佛" class="headerlink" title="TV Buddha 电视佛"></a>TV Buddha 电视佛</h3><p><img src="https://i.loli.net/2019/03/15/5c8b10bde86a3.jpg" alt="43011_526229_154836"></p><font size="3" color="#888888">TV Buddha (1974) Closed circuit video installation, bronze sculpture.</font><p>在这件作品中，佛陀是沉思和启蒙的象征，而把它放在电视与摄像机的对面则象征了现代技术。白南准作为终身修行的佛教徒，用这个作品来质疑自我在一个与灵性与技术相交的时代中的作用。</p><p><img src="https://i.loli.net/2019/03/15/5c8b11e24929e.jpg" alt="0_Z5rIh0WMze5LCRP4"></p><font size="3" color="#888888">TV Buddha (1989) Closed Circuit video installation, bronze sculpture.</font><p><img src="https://i.loli.net/2019/03/15/5c8b11e982031.jpg" alt="0_VWbV4LBdFDb1yhNb"></p><font size="3" color="#888888">Buddha Watching TV, (1974/1997) Stone sculpture, soil, closed circuit video camera, video monitor, tripod, plywood base.</font><p>该系列中的每件作品都由一尊坐在镜头和电视对面的佛像组成。通过摄像机的投射，佛陀凝视着自己在电视屏幕上的形象，在一场持久对视着的竞争中提出了自我和人性的问题。</p><h3 id="Electronic-Superhighway-电子超级高速路"><a href="#Electronic-Superhighway-电子超级高速路" class="headerlink" title="Electronic Superhighway 电子超级高速路"></a>Electronic Superhighway 电子超级高速路</h3><p><img src="https://i.loli.net/2019/03/15/5c8b16b872049.jpg" alt="SAAM-2002.23_1"><br> <font size="3" color="#888888">Electronic Superhighway, 1974, fifty-one channel video installation , custom electronics, neon lighting, steel and wood</font></p><p>当白南准于1964年来到美国时，州际高速公路系统只有9年的历史，而高速公路则为每个人提供了“see the U.S.A. in your Chevrolet.”(在你的雪佛兰中看美国)的自由。</p><p><img src="https://i.loli.net/2019/03/15/5c8b1fc8efa67.jpeg" alt="Close-up-of-Nam-June-Paik-Electronic-Superhighway-Continental-U.S.-Alaska-Hawaii-1995-at-the-Smithsonian-American-Art-Museum-2-1000x750"></p><font size="3" color="#888888"> Electronic Superhighway (detail), 1974</font><p>他通过霓虹灯与电视，回忆了五彩缤纷的地图和汽车旅馆的炽热诱惑，这些诱惑使美国人向开阔的道路招手。</p><p><img src="https://i.loli.net/2019/03/15/5c8b1d620ba06.gif" alt="highway11"><br> <font size="3" color="#888888">Electronic Superhighway (detail), 1974</font></p><p>霓虹灯不同的颜色区分了不同地域之间的显著差异，每个区域中的电视播放着最有地域特色的内容。</p><p><img src="https://i.loli.net/2019/03/15/5c8b1f84d3ab1.gif" alt="superhighway4"><br> <font size="3" color="#888888">Electronic Superhighway (detail), 1974</font></p><p>白南准的灵感来自于美国的洲际高速公路，他将这个视频装置命名为电子高速公路，以表达他对未来的愿景，随着技术的进步，未来的通信将是无边界的。而白南准设想的内容现已通过互联网体现出来，这个术语今天已被广泛使用。</p><h3 id="Zen-for-TV"><a href="#Zen-for-TV" class="headerlink" title="Zen for TV"></a>Zen for TV</h3><p><img src="https://i.loli.net/2019/03/15/5c8b21ee9934e.jpg" alt="cri_000000244077"></p><font size="3" color="#888888">Zen for TV，1963</font><p>电视禅是一部被剥夺其形式和功能的电视机，因而是一种破坏行为。观众在一个竖直的黑暗屏幕上看到一条抽象的垂直发光线而不是其他电视节目。</p><p><img src="https://i.imgur.com/OXezQWI.gif" alt="zen (1)"></p><font size="3" color="#888888">白南准早期的采访视频，Youtube</font><p>把禅这种生活哲学与电视结合，电视成为了安静、沉浸的对象。</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p><img src="https://i.imgur.com/K772JTI.jpg" alt="zNpkmHTFCTkL_2340x1316"></p><font size="3" color="#888888">Nam June Paik, TV Chair, 1968</font> <p><img src="https://i.imgur.com/8GL3EPc.jpg" alt="qYLIhUtwOvOj_1170x658"></p><font size="3" color="#888888">Nam June Paik, Bakelite Robot, 2002</font> <p><img src="https://i.imgur.com/uL7r9fj.jpg" alt="WWVA2LFNH0r0_1170x658"></p><font size="3" color="#888888">Nam June Paik, TV Cello, 2003</font> <p><img src="https://i.imgur.com/P91JnVW.jpg" alt="D5SWLDLRh1UC_2340x1316"></p><font size="3" color="#888888">Nam June Paik, Candle TV, 1991–2003</font> <p><img src="https://i.imgur.com/mQogCR1.jpg" alt="bBblQ6LK0o1W_585x329"></p><font size="3" color="#888888">Nam June Paik, Standing Buddha with Outstretched Hand, 2005</font><p><img src="https://i.imgur.com/ECom4yh.jpg" alt="hBDFCJI6GYLT_2340x1316"><br> <font size="3" color="#888888">Nam June Paik, Chinese Memory, 2005</font> </p><!-- ## Nam June Paik  --><p><img src="https://i.loli.net/2019/03/15/5c8b6b51cb8f3.png" alt="2"></p><p><img src="https://i.imgur.com/6TwmMW4.jpg" alt="15-paik-timthumb"></p><p>白南准于1932年在韩国首尔出生于一个富裕的工业家庭，在1950年朝鲜战争开始时，他先是逃往了香港，然后到了日本。1956年在东京大学完成美学、音乐史、艺术史和哲学的学习，随后前往德国，追求他对前卫音乐，作曲和表演的兴趣。</p><p><img src="https://i.imgur.com/qP3gthn.jpg" alt="a869fa71dac536a48"></p><p>1958年，他被先锋派作曲家约翰·凯奇（John Cage）的演讲所开悟，使他从一位学习西方古典音乐和现代音乐的普通学生，转而成为一位在多媒体艺术方面发展的实验艺术家。</p><p><img src="https://i.loli.net/2019/03/15/5c8b3f98087ff.jpg" alt="Ev9rdkiroI9K_2400x2400"></p><font size="3" color="#888888"> Magnet TV, 1965</font><p>20世纪60年代，白南准的名字与无政府主义艺术思潮：激浪派（Fluxus）联系在一起，被视为当时最具代表性的先锋艺术家。</p><p><img src="https://i.loli.net/2019/03/15/5c8b51530b690.jpg" alt="800px-Frankfurt_Medien_Denkmal"></p><font size="3" color="#888888">Pre-Bell-Man，雕像</font><p>综看来，白南准看似更是一个“流行艺术家”，通过最广泛的媒介进行再创作，创造出既通俗又形而上的作品。</p><p><img src="https://i.loli.net/2019/03/15/5c8b3f0b7bd83.jpg" alt="Lennon_Ono_Paik_Abe_at_Galeria_Bonino_NY_1971"></p><font size="3" color="#888888">约翰列侬，小野洋子，白南准和Shuya Abe在1971年11月23日在纽约Galeria Bonino拍照</font><p>在那个年代，艺术家一方面惊叹于有史以来最强大的媒介——电视，同时又对商业电视网所播放的内容不屑一顾。而索尼公司（Sony）推出了手提式摄影设备Portapak，使艺术家们发现了新的艺术创作的媒介。</p><p><img src="https://i.loli.net/2019/03/15/5c8b50c50005f.jpg" alt="Sony_AV-3400_Porta_Pak_Camera"></p><font size="3" color="#888888">Portapak是一个电池供电的，自包含的视频磁带 模拟记录系统。它于1967年推向市场，可以由一个人携带和操作。</font><p>白南准成为使用电视媒介来表达艺术的第一人，他的作品将艺术、媒体、技术、流行文化和先锋派艺术结合在一起，影响着当代艺术。</p><p><img src="https://i.loli.net/2019/03/15/5c8b518ab6cc7.jpg" alt="afb7183bd97cf60ca070f44097f696fc"></p><font size="3" color="#888888">影响装置行为代表作《电子大提琴》1971年与大提琴家(Charlotte Moorman)</font><p>在录像艺术领域，白南准也充分理解这个由他引领而来的新时代的艺术挑战，他坚持艺术和科技结合的理念，并进一步坚信艺术和科技结合的中心目标“不是制造另一个科学玩具，而是将科技和电子媒介人性化”。</p><p><img src="https://i.loli.net/2019/03/15/5c8b525f95665.jpg" alt="56-284002-njp-image-1-transistortv-copy"></p><p>随着信息技术的快速发展，人类的感官经验在新的电信科技媒介面前，不断得到整合、扩张，人的认知模式在这个过程总随之改变。</p><p><img src="https://i.imgur.com/1VekiIT.jpg" alt="Bm3Zx5FRvPtX_2400x4800"></p><font size="3" color="#888888">Nam June Paik’s Robot K-456 (1964)</font><p><img src="https://i.loli.net/2019/03/15/5c8b533994c9b.jpg" alt="_mtlqBAh6avf_740x1480"></p><font size="3" color="#888888">Staged accident with Robot K-456 in front of the Whitney Museum of American Art, New York, 1982</font><p>与此同时，录像或录影艺术在数字化时代，在现代创作理念的驱动下，并通过开创性的应用和整合新媒体投入到艺术实践之中，必将再现艺术的新风貌。</p><p><img src="https://i.imgur.com/Q1Jx45g.jpg" alt="01-PaikVideoEditingMercerSt_photobyHeald"></p><font size="3" color="#888888">1999年，白南准在纽约美世街（Mercer Street）家中的视频剪辑室</font><p><img src="https://i.imgur.com/Qrsjvg6.jpg" alt="e8752c2d77cdadeea13279fe0e6c5039"></p><font size="3" color="#888888">白南准一生的追求：探索当代科技和传统文化如何使新的艺术表达成为可能。</font><p><img src="https://i.loli.net/2019/03/15/5c8b6b33f0d38.png" alt="3"></p><p>然后是一些个人的想法。白南准的作品中最吸引我的部分是他所使用的材料，CRT电视机。</p><p><img src="https://i.imgur.com/mCn4PRl.jpg" alt="a31db723ee100e9e11c2d8e1a4b7ee2d"></p><font size="3" color="#888888">索尼特丽珑®(Trinitron®)电视的海报</font><p>CRT电视也就是俗称的“大屁股电视”，其原理在中学物理书上写的一清二楚，通过电子枪射出电子束，电子经过磁场偏转，打在屏幕上的荧光屏上，产生图像。</p><p><img src="https://i.imgur.com/ikS6mzC.png" alt="CRT_color_enhanced"></p><font size="3" color="#888888">阴极射线管原理： 1.三个电子发射器（用于红色，绿色和蓝色荧光点） 2. 电子束  3. 聚焦线圈 4. 偏转线圈 5. 最终阳极的连接（称为“ultor”） 6. 用于分离显示图像的红色，绿色和蓝色部分光束的掩模   7.具有红色，绿色和蓝色区域的磷光体层（屏幕） 8.  磷光体涂层内侧的特写屏幕</font><p>这种电视跟现今的电视相比最大的差别是使用的是模拟信号（Analog），而不是数字信号（Digital）。</p><p><img src="https://i.imgur.com/aJ09cpd.jpg" alt="1-1PH41HP1L5"></p><font size="3" color="#888888">图中光滑的曲线为模拟信号，方块的部分为数字信号</font><p>而对我们来说实际能感受到的差别是，模拟信号在转化为数字信号的过程中大部分数据会丢失。最直接的体现就是照片的像素，数码照片（数字信号）放大后会有像素颗粒出现，但是胶片（模拟信号 ）呈现的图像，无论如何放大也不会出现像素颗粒。</p><p><img src="https://i.imgur.com/nVS0QpQ.jpg" alt="胶片VS数码"></p><p>而我对这两种信号的理解是，数字信号呈现的对象虽然可以无限接近现实，但是其本质上是经过人为的再编码，而这种编码理论上无法完美的复原自然事物。而模拟信号虽然会有噪波，但是平滑的再现了自然事物的特征。 </p><p><img src="https://i.imgur.com/u758GYL.jpg" alt="3de811ace39990500af9cc25b8e5f4d5"></p><p>早期的电子产品几乎全是用模拟信号，磁带、菲林、唱片…… 而如今模拟信号已经被淘汰，唯一能见到的地方似乎就是实验室中的示波器了。最大的原因是，数字信号容易存储，计算。</p><p><img src="https://i.imgur.com/kzaSxQj.jpg" alt="2a15d3e64320d9178bbde3820213ac2e"></p><p>似乎有些扯远，但是我想说的是按照白南准的理念，把电子媒介人性化，最好的材料就是使用更接近自然的模拟信号的电子媒介。CRT电视就是这种媒介。</p><p>参考资料：<br><a href="https://americanart.si.edu/artist/nam-june-paik-3670" target="_blank" rel="noopener">https://americanart.si.edu/artist/nam-june-paik-3670</a><br><a href="https://www.artnetnews.cn/people/bainanzhun-6560" target="_blank" rel="noopener">https://www.artnetnews.cn/people/bainanzhun-6560</a><br><a href="https://medium.com/@codenamecatstac/nam-june-paiks-tv-buddhas-e3606957b23f" target="_blank" rel="noopener">https://medium.com/@codenamecatstac/nam-june-paiks-tv-buddhas-e3606957b23f</a><br><a href="https://americanart.si.edu/artwork/electronic-superhighway-continental-us-alaska-hawaii-71478" target="_blank" rel="noopener">https://americanart.si.edu/artwork/electronic-superhighway-continental-us-alaska-hawaii-71478</a><br><a href="https://monoskop.org/Nam_June_Paik" target="_blank" rel="noopener">https://monoskop.org/Nam_June_Paik</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C O L O R T R I A L</title>
      <link href="/2019/C-O-L-O-R-T-R-I-A-L/"/>
      <url>/2019/C-O-L-O-R-T-R-I-A-L/</url>
      
        <content type="html"><![CDATA[<h2 id="颜色实验"><a href="#颜色实验" class="headerlink" title="颜色实验"></a>颜色实验</h2><p>想要使以后的作品颜色更加丰富，和谐。先做一些色彩实验吧。</p><p>可以尝试用手指戳下面色块。</p><div id="container" style="width:400px"></div><script type="text/javascript">'use strict';var tileCountX = 2;var tileCountY = 10;var colorsLeft = [];var colorsRight = [];var colors = [];var interpolateShortest = true;const ww = document.getElementById("container").offsetWidth-40;function setup() {    var myCanvas = createCanvas(ww,ww);    myCanvas.parent("container");    colorMode(HSB);    noStroke();    shakeColors();}function draw() {    tileCountX = int(map(mouseX, 0, width, 2, 100));    tileCountY = int(map(mouseY, 0, height, 2, 10));    var tileWidth = width / tileCountX;    var tileHeight = height / tileCountY;    var interCol;    colors = [];    for (var gridY = 0;gridY < tileCountY;gridY++){        var col1 = colorsLeft[gridY];        var col2 = colorsRight[gridY];        for (var gridX = 0;gridX<tileCountX;gridX++){            var amount = map(gridX, 0, tileCountX - 1, 0, 1);            if (interpolateShortest) {              colorMode(RGB);              interCol = lerpColor(col1, col2, amount);              colorMode(HSB);            } else {              interCol = lerpColor(col1, col2, amount);            }            fill(interCol);            var posX = tileWidth *gridX;            var posY = tileHeight*gridY;            rect(posX,posY,tileWidth,tileHeight);            colors.push(interCol);        }    }}function shakeColors() {    for(var i = 0;i<tileCountY;i++){        colorsLeft[i] = color(random(0,60),random(0,100),100);        colorsRight[i] = color(random(160,190),100,random(0,100));    }}</script><button onclick="shakeColors()" style="color : #ffF">CHANGE COLOR</button>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p a n G E N E R A T O R</title>
      <link href="/2019/p-a-n-G-E-N-E-R-A-T-O-R/"/>
      <url>/2019/p-a-n-G-E-N-E-R-A-T-O-R/</url>
      
        <content type="html"><![CDATA[<h1 id="未来艺术该有的样子-panGenerator"><a href="#未来艺术该有的样子-panGenerator" class="headerlink" title="未来艺术该有的样子 | panGenerator"></a>未来艺术该有的样子 | panGenerator</h1><p><img src="http://pic.drafff.art/hexo/pangenerator.jpg" alt="pangenerator"></p><h1 id><a href="#" class="headerlink" title="#"></a>#</h1><p><img src="http://pic.drafff.art/hexo/小标题1.jpg" alt="小标题1"></p><p>比特(bit)是计算机数据的最小单位，而原子(atom)是现实物质的最小单位。</p><p>混合比特和原子(blending bits &amp; atoms together)，言下之意就是把就是把计算机技术与现实结合。</p><h3 id="spiralalala"><a href="#spiralalala" class="headerlink" title="spiralalala"></a>spiralalala</h3><p><img src="http://pic.drafff.art/hexo/web-thumbnail.jpg" alt="web-thumbnail"><br>singing architecture 歌唱的建筑</p><p>这个作品的名字已经大致体现了作品的样子。”spiral”螺旋，后面的”lala”表示了回音，光从名字就可以看出这是一个在螺旋的楼梯上的声音艺术装置。</p><p><img src="http://pic.drafff.art/hexo/MAIN.00_00_10_22.Still003-1.jpg" alt="MAIN.00_00_10_22.Still003-1"></p><p>人与建筑的交互开始于将球塞入麦克风。然后声音录制开始，在声音录制结束后，球被释放以沿着轨道向下滑动。</p><p><img src="http://pic.drafff.art/hexo/MAIN.00_00_18_21.Still013.jpg" alt="MAIN.00_00_18_21.Still013"></p><p>为了实现声音的变换与球的位置、速度同步，轨道上每隔一定距离有一个传感器。有了球通过每个传感器的速度，就能用程序跟踪这个球。</p><p><img src="http://pic.drafff.art/hexo/MAIN.00_00_24_17.Still014.jpg" alt="MAIN.00_00_24_17.Still014"></p><p>为了使声音更加立体，每层楼梯都装有一个扬声器。从而产生了声音随小球“下落”的错觉。</p><p><img src="http://pic.drafff.art/hexo/fc5970d8d2d92bed565f2833e0b2dc6d.jpg" alt="fc5970d8d2d92bed565f2833e0b2dc6d"></p><h3 id="hash2ash"><a href="#hash2ash" class="headerlink" title="hash2ash"></a>hash2ash</h3><p><img src="http://pic.drafff.art/hexo/2018_02_01_PAN_GENERATOR_HASH2ASH_08.jpg" alt="2018_02_01_PAN_GENERATOR_HASH2ASH_08">everything saved will be lost 一切终将逝去</p><p>这一作品的名字同样也很有深度，”hash”即哈希，一种储存数据的算法。”ash”尘土。从数据变为尘土。这个在华沙国家民族博物馆创建的互动装置会将你的自拍变成一堆灰烬。</p><p><img src="http://pic.drafff.art/hexo/2018_02_01_PAN_GENERATOR_HASH2ASH_06.jpg" alt="2018_02_01_PAN_GENERATOR_HASH2ASH_06"></p><p>显示屏上会提示你在手机上自拍，并在屏幕上呈现数字砾石。片刻之后你的脸部会分崩离析，真正的黑色砾石开始从屏幕底部落下，与数字模拟完美同步。最终在屏幕下方形成一个黑的的土堆。</p><p><img src="http://pic.drafff.art/hexo/2018_02_01_PAN_GENERATOR_HASH2ASH_10.jpg" alt="2018_02_01_PAN_GENERATOR_HASH2ASH_10"></p><p>这个作品表达了数字的信息最总会消失，即使是关于我们自己的信息也会消失。</p><p>看完这个作品让我想到了《三体》中的一个桥段，渺小的人类发现以现有的科技不管用什么手段存储信息，在宇宙的时间尺度上甚至不能保存一瞬间，最后唯一的办法就是在石碑上刻字来保存信息。</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p><img src="http://pic.drafff.art/hexo/小标题2.jpg" alt="小标题2"></p><p><img src="http://pic.drafff.art/hexo/panGenerator,%20od%20lewej%20Krzysztof%20Golinski,%20Jakub%20Kozniewski,%20Piotr%20Bar.jpg" alt="panGenerator, od lewej Krzysztof Golinski, Jakub Kozniewski, Piotr Bar"></p><p>让我们看看这些作品的创造者。</p><p>panGenerator是一个位于波兰华沙的新媒体艺术设计团队，自2010年以来，该团队创建了独特的项目，探索创造性表达以及与观众的互动的新方式。</p><p><img src="http://pic.drafff.art/hexo/Alan%20Zenreich,%20from%20Creative%20Black%20Book%20Photography%201985.jpg" alt="Alan Zenreich, from Creative Black Book Photography 1985"></p><p>他们模糊了艺术、设计和工程之间的界限，创建了许多由文化机构或商业品牌委托的大型互动装置，以及纯粹的实验性音乐界面或投机和批判性的艺术作品。</p><p><img src="http://pic.drafff.art/hexo/Wind_in_the_willows.jpg" alt="Wind_in_the_willows"></p><p>关于名字中的这个潘神(Pan)，我查阅了一些资料，18世纪古典学者、鉴赏家理查德·佩恩(Richard Payne Knight) 有一段关于潘神的描述：</p><p>“Pan is represented pouring water upon the organ of generation; that is, invigorating the active creative power by the prolific element.”(潘神代表向创造的器官浇水，通过丰富的元素鼓舞创造力)</p><p>我推测他们的名字出自这句话，不由得感叹真会取名。</p><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><p><img src="http://pic.drafff.art/hexo/小标题3.jpg" alt="小标题3"></p><p>pangenerator solo exhibition 早期举办的一个展览</p><p>早期的艺术作品仅仅局限于单一的简单的元素，如纸和画笔，感光元件，或者单纯的声音。这些元素当然能够表达作者的想法，也有非常棒作品，但是从宏观一点的角度看这些作品始终使扁平的。</p><p><img src="http://pic.drafff.art/hexo/357daac20ebfcfb3470c37c37f11eada.jpg" alt="357daac20ebfcfb3470c37c37f11eada"></p><p>从人类的整个历史来看，艺术的发展本来就是随着科技的发展而发展的。从原始人的洞穴壁画，到纸张、笔的发明而后有了格式各样的绘画形式。透视法的发明、牛顿对光与色的进一步发现都对艺术作品有了巨大的推动作用。</p><p><img src="http://pic.drafff.art/hexo/4a9a02c5041a2000a9d67aa68e242a47.jpg" alt="4a9a02c5041a2000a9d67aa68e242a47"></p><p>而在科技发展更加迅猛的今天，诸如计算机技术、虚拟现实技术等更多的科技应被艺术采纳，一件立体而丰富的艺术作品中因该广泛的采用多种元素。这就是未来艺术该有的样子。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://culture.pl/pl/tworca/pangenerator" target="_blank" rel="noopener">https://culture.pl/pl/tworca/pangenerator</a><br><a href="https://pangenerator.com/projects/spiralalala/" target="_blank" rel="noopener">https://pangenerator.com/projects/spiralalala/</a><br><a href="https://pangenerator.com/projects/hash2ash/" target="_blank" rel="noopener">https://pangenerator.com/projects/hash2ash/</a><br><a href="https://en.wikipedia.org/wiki/Pan_(god" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pan_(god</a>)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I N  A N D  O U T</title>
      <link href="/2019/I-N-A-N-D-O-U-T/"/>
      <url>/2019/I-N-A-N-D-O-U-T/</url>
      
        <content type="html"><![CDATA[<h1 id="In-and-Out"><a href="#In-and-Out" class="headerlink" title="In and Out"></a>In and Out</h1><p>来自Openprocessing的一段代码使用了复杂的三角函数和递归运算，还没悟透。</p><div id="container" style="width:400px"></div><p><div id="container1"></div> <input type="range" id="reclevel" max="20" min="1" step="1" value="6"><br>▲拖动滑块调整递归层数。</p><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;let level = 6;function setup() { var myCanvas = createCanvas(ww,ww);    myCanvas.parent("container");    strokeWeight(width/180);    }    function draw() {        background(240);        let level = Number(document.getElementById("reclevel").value);        harom(width/1.08,height/1.174,width/13.4,height/1.174,level,(sin(0.0005*millis()%(2*PI))+1)/2);    }    function harom(ax,  ay, bx,  by, level, ratio){        if(level!=0){        var  vx,vy,nx,ny,cx,cy;        vx=bx-ax;        vy=by-ay;        nx=cos(PI/3)*vx-sin(PI/3)*vy;         ny=sin(PI/3)*vx+cos(PI/3)*vy;         cx=ax+nx;        cy=ay+ny;        line(ax,ay,bx,by);        line(ax,ay,cx,cy);        line(cx,cy,bx,by);        harom(ax*ratio+cx*(1-ratio),ay*ratio+cy*(1-ratio),ax*(1-ratio)+bx*ratio,ay*(1-ratio)+by*ratio,level-1,ratio);        }    }    </script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R E C T A N G L E S</title>
      <link href="/2019/R-E-C-T-A-N-G-L-E-S/"/>
      <url>/2019/R-E-C-T-A-N-G-L-E-S/</url>
      
        <content type="html"><![CDATA[<h1 id="R-E-C-T-A-N-G-L-E-S"><a href="#R-E-C-T-A-N-G-L-E-S" class="headerlink" title="R E C T A N G L E S"></a>R E C T A N G L E S</h1><p>尝试触摸以下区域</p><p><div id="container" style="width:400px"></div></p><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;var tileCount = 20;var moduleColor;var moduleAlpha = 180;var maxDistance = 500;function setup() {  var myCanvas = createCanvas(ww,ww);    myCanvas.parent("container");  noFill();  strokeWeight(3);  moduleColor = color(0, 0, 0, moduleAlpha);}function draw() {  clear();  stroke(moduleColor);  for (var gridY = 0; gridY < width; gridY += 25) {    for (var gridX = 0; gridX < height; gridX += 25) {      var diameter = dist(mouseX, mouseY, gridX, gridY);      diameter = diameter / maxDistance * 40;      push();            noFill();      translate(gridX, gridY, diameter * 5);      rect(0, 0, diameter, diameter); // also nice: ellipse(...)      pop();    }  }}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C U B E W A V E</title>
      <link href="/2019/C-U-B-E-W-A-V-E/"/>
      <url>/2019/C-U-B-E-W-A-V-E/</url>
      
        <content type="html"><![CDATA[<h1 id="Cube-Wave-方块波"><a href="#Cube-Wave-方块波" class="headerlink" title="Cube Wave 方块波"></a>Cube Wave 方块波</h1><p>来自Twitter大神<a href="https://twitter.com/beesandbombs" target="_blank" rel="noopener">@beesandbombs</a>的一张动图。</p><p><img src="http://pic.drafff.art/hexo/20190215141626-be14ef72ff.[gif-2-mp4.com].gif" alt="20190215141626-be14ef72ff.[gif-2-mp4.com]"></p><p>主要使用了三角函数实现平滑的波动。</p><p><div id="container1"></div><input type="range" id="speedRange" max="0.4" min="0" step="0.001" value="0.1"><br>▲拖动滑块调整波动频率。</p><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;let angle = 0;let ma;let maxD;function setup() {  createCanvas(ww, ww, WEBGL);var myCanvas = createCanvas(ww,ww,WEBGL);myCanvas.parent("container1");  ma = atan(cos(QUARTER_PI));  maxD = dist(0, 0, width/2, width/2);}function draw() {let w = width/15;  background(100);  ortho(-400, 400, 400, -400, 0, 1000);  rotateX(ma);  rotateY(-QUARTER_PI);  for (let z = 0; z < width; z += w) {    for (let x = 0; x < width; x += w) {      push();      let d = dist(x, z, width / 2, width / 2);      let offset = map(d, 0, maxD, -PI, PI);      let a = angle + offset;      let h = floor(map(sin(a), -1, 1, 150, width));      translate(x - width / 2, 0, z - width / 2);      normalMaterial();      box(w, h, w);      //rect(x - width / 2 + w / 2, 0, w - 2, h);      pop();    }  }  angle += Number(document.getElementById("speedRange").value);}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>S O M E T H I N G - 1</title>
      <link href="/2019/S-O-M-E-T-H-I-N-G-1/"/>
      <url>/2019/S-O-M-E-T-H-I-N-G-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一-个-B-U-G"><a href="#一-个-B-U-G" class="headerlink" title="一 个 B U G"></a>一 个 B U G</h1><p>做一个立方体矩阵的时候出了点BUG，还挺好看的，上传了。</p><div id="container" style="width:400px"></div><script type="text/javascript">let angle = 0;const ww = document.getElementById("container").offsetWidth-40;let recWidth = 13;function setup() {  var myCanvas = createCanvas(ww, 500,WEBGL);  myCanvas.parent("container");}function draw() {    background(120);    ortho();    // translate(width / 2, height / 2);    rectMode(CENTER);    // directionalLight(240, 135, 200,0,-1, 0);    let offset = 0;    let Yoffset = 0;    rotateX(PI / 3);    // rotateY(PI / 3);    rotateZ(PI/4);    for (let y = 0; y < width; y += recWidth + 5) {        offset = Yoffset;        for (let x = 0; x < width; x += recWidth + 5) {            push();            let a = angle + offset;            // noStroke();            // fill(255);            // ambientMaterial(255);            normalMaterial();            translate(x - width / 2, y - width / 2,0);            let h = map(sin(a), -1, 1, 0, 200);            box(recWidth, recWidth, h);            // rect(x - width /2 + recWidth/2, 0,recWidth, h);            offset += TWO_PI / (width / recWidth);            pop();        }        Yoffset += TWO_PI / (width / recWidth);    }    angle += 0.08;}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P H Y L L O T A D X I S</title>
      <link href="/2019/P-H-Y-L-L-O-T-A-D-X-I-S/"/>
      <url>/2019/P-H-Y-L-L-O-T-A-D-X-I-S/</url>
      
        <content type="html"><![CDATA[<h1 id="叶-序"><a href="#叶-序" class="headerlink" title="叶 序"></a>叶 序</h1><p><strong> 叶序（Phyllotaxis）</strong> 是叶梗上的一群、或一丛叶，依固定的方式排列，是植物的固定特征之一。</p><p><img src="http://pic.drafff.art/hexo/微信截图_20190213032851.png" alt="微信截图_20190213032851"></p><p>来自混乱博物馆（CHAOS MUSEUM）第199期，<a href="https://www.bilibili.com/video/av27410638" target="_blank" rel="noopener">黄金分割的妙处</a>。</p><p><img src="http://pic.drafff.art/微信截图_20190213021905.png" alt="微信截图_20190213021905"></p><p>在植物生长时每隔一个角度就长出一个侧芽，如果这个角度太过平庸，新芽旋转几周后就会和老的芽对在一起，既浪费空间又争夺资源。</p><p><img src="http://pic.drafff.art/1.gif" alt="1"></p><p>只要这个旋转角度足够刁钻，新芽就不会转回原点，如宝塔花菜。</p><p><img src="http://pic.drafff.art/800px-Fractal_Broccoli.jpg" alt="800px-Fractal_Broccoli"></p><p>这个刁钻角度就是圆周角的黄金分割。</p><p><img src="http://pic.drafff.art/2.gif" alt="2"></p><p>为了模拟了这种旋转产生的图案,可由 360/(1+φ）＝540－180√5＝137.507764 得出黄金角约等于137.5，于是有了下面的图案。</p><div id="container" style="width:400px"></div><script type="text/javascript">var n = 0;var c = 3.2;var Angle = 137.50776405003785464634873962837;const ww = document.getElementById("container").offsetWidth-40;function setup() {  var myCanvas = createCanvas(ww, ww);  myCanvas.parent("container");  angleMode(DEGREES);  background(0);}function draw() {  var a = n * Angle;  var r = c * sqrt(n);  var x = r * cos(a) + width / 2;  var y = r * sin(a) + height / 2;  fill(255);  noStroke();  ellipse(x, y, 4);  n++;}function getInputValue() {  var inputValue = document.getElementById("degree").value;  if (inputValue) {    return inputValue;  }}function restart() {  background(0);  n = 0;  if( getInputValue()){    Angle = getInputValue()  }}</script><div id="zhege"></div><p>可以在以下文本框中输入任意角度</p><p><input type="text" id="degree" value="137.5" onfocus="if(value=='137.5'){value=''}" onblur="if(value==''){value='137.5'}"><button onclick="restart()" style="color : #ffF">S U B M I T</button></p><p>这里还有个相差很小的角度形成的图案，分别为137.3和137.6，大家可以尝试下。</p><p><img src="http://pic.drafff.art/hexo/微信截图_20190213032909.png" alt="微信截图_20190213032909"></p><p>更多关于叶序的信息，<a href="http://algorithmicbotany.org/papers/abop/abop-ch4.pdf" target="_blank" rel="noopener">这里有份资料</a>，感兴趣可以翻阅一下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>M E N G E R S P O N G E</title>
      <link href="/2019/M-E-N-G-E-R-S-P-O-N-G-E/"/>
      <url>/2019/M-E-N-G-E-R-S-P-O-N-G-E/</url>
      
        <content type="html"><![CDATA[<h1 id="门-格-海-绵"><a href="#门-格-海-绵" class="headerlink" title="门 格 海 绵"></a>门 格 海 绵</h1><hr><p><img src="https://i.loli.net/2019/02/10/5c5fc43f36a16.png" alt="Menger-Schwamm-farbig.png"></p><p>门格海绵的结构可以用以下方法形象化：<br>-</p><blockquote><p>1.从一个正方体开始。（第一个图像）<br>2.把正方体的每一个面分成9个正方形。这将把正方体分成27个小正方体，像魔方一样。<br>3.把每一面的中间的正方体去掉，把最中心的正方体也去掉，留下20个正方体（第二个图像）。<br>4.把每一个留下的小正方体都重复第1-3个步骤。<br>5.把以上的步骤重复无穷多次以后，得到的图形就是门格海绵。</p></blockquote><p><img src="https://i.loli.net/2019/02/10/5c5fc54aae1df.jpg" alt="Menger_sponge_(Level_0-3).jpg"></p><h2 id="以下是用Processing模拟的门格海绵，请谨慎触摸以下区域。"><a href="#以下是用Processing模拟的门格海绵，请谨慎触摸以下区域。" class="headerlink" title="以下是用Processing模拟的门格海绵，请谨慎触摸以下区域。"></a>以下是用Processing模拟的门格海绵，请谨慎触摸以下区域。</h2><canvas data-processing-sources="Menger_Sponge_Fractal.pde Box.pde"></canvas><blockquote><p><strong>门格海绵</strong>（<strong>Menger sponge、Menger universal curve</strong>）是分形的一种。它是一个<strong>通用曲线</strong>，因为它的拓扑维数为一，且任何其它曲线或图都与门格海绵的某个子集同胚。它有时称为门格-谢尔宾斯基海绵或谢尔宾斯基海绵。它是<strong>康托尔集和谢尔宾斯基地毯</strong>在三维空间的推广。它首先由奥地利数学家<strong>卡尔·门格</strong>在1926年描述，当时他正在研究拓扑维数的概念。</p><p>(来自维基百科)</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VAPOR wAVE</title>
      <link href="/2019/VAPOR-wAVE/"/>
      <url>/2019/VAPOR-wAVE/</url>
      
        <content type="html"><![CDATA[<h1 id="VAPOR-wAVE"><a href="#VAPOR-wAVE" class="headerlink" title="VAPOR wAVE"></a>VAPOR wAVE</h1><p>基于Perlin Noise的蒸汽波图。</p><p>实时产生的噪波。</p><canvas data-processing-sources="PerlinNoise_Java.pde"></canvas>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FireWork</title>
      <link href="/2019/FireWork/"/>
      <url>/2019/FireWork/</url>
      
        <content type="html"><![CDATA[<h1 id="F-I-R-E-W-O-R-K"><a href="#F-I-R-E-W-O-R-K" class="headerlink" title="F I R E W O R K"></a>F I R E W O R K</h1><p>新 年 快 乐 ！</p><div id="container" style="width:400px"></div><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;var gravity;var fireworks = [];function setup() { var myCanvas = createCanvas(ww,400);    myCanvas.parent("container");  gravity = createVector(0, 0.2);  stroke(255);  strokeWeight(4);  background(0);}function draw() {  background(51, 70);  if (random(1) < 0.03) {    fireworks.push(new Firework());  }  for (var i = fireworks.length - 1; i >= 0; i--) {    fireworks[i].updata();    fireworks[i].show();    // if (fireworks[i].firework.pos.y > height){    //   fireworks.splice(i,1);    // }    if (fireworks[i].done()) {      fireworks.splice(i, 1);    }  }}function Firework() {  this.firework = new Particle(random(width), height, true);  this.exploded = false;  this.particles = [];  this.hu = 0;  this.done = function() {    if (this.exploded && this.particles.length === 0) {      return true;    } else {      return false;    }  };  this.updata = function() {    if (!this.exploded) {      this.firework.applyForce(gravity);      this.firework.update();      if (this.firework.vel.y >= 0) {        this.exploded = true;        this.explode();      }    }    for (var i = this.particles.length - 1; i >= 0; i--) {      this.particles[i].applyForce(gravity);      this.particles[i].update();      if (this.particles[i].done()) {        this.particles.splice(i, 1);      }    }  };  this.explode = function() {    for (var i = 0; i < 100; i++) {      var p = new Particle(this.firework.pos.x, this.firework.pos.y);      this.particles.push(p);    }  };  this.show = function() {    if (!this.exploded) {      this.firework.show();    }    for (var i = 0; i < this.particles.length; i++) {      this.particles[i].show();    }  };}function Particle(x, y, firework) {  this.firework = firework;  this.pos = createVector(x, y);  this.lifespan = 255;  if (firework) {    this.vel = createVector(0, random(-12, -8));  } else {    this.vel = p5.Vector.random2D();    this.vel.mult(random(2, 10));  }  this.acc = createVector(0, 0);  this.applyForce = function(force) {    this.acc.add(force);  };  this.update = function() {    if (!this.firework) {      this.vel.mult(0.9);      this.lifespan -= 3;    }    this.vel.add(this.acc);    this.pos.add(this.vel);    this.acc.mult(0);  };  this.show = function() {    if (!this.firework) {      strokeWeight(2);      stroke(255, this.lifespan);    } else {      stroke(255, 255);      strokeWeight(4);    }    point(this.pos.x, this.pos.y);  };  this.done = function() {    if (this.lifespan < 0) {      return true;    } else {      return false;    }  };}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关 于 流 浪 地 球</title>
      <link href="/2019/%E5%85%B3-%E4%BA%8E-%E6%B5%81-%E6%B5%AA-%E5%9C%B0-%E7%90%83/"/>
      <url>/2019/%E5%85%B3-%E4%BA%8E-%E6%B5%81-%E6%B5%AA-%E5%9C%B0-%E7%90%83/</url>
      
        <content type="html"><![CDATA[<h2 id="行星飞船"><a href="#行星飞船" class="headerlink" title="行星飞船"></a>行星飞船</h2><p>《流浪地球》的背景是太阳即将发生氦闪，人类选择将地球改造成巨大的飞船，使它跟着人类一起在太空中流浪。刘慈欣对于改造的设定描写的非常详细。为了推动地球，地球发动机总共有一万二千台，分布在亚洲和美洲大陆的各个平原上，而发动机使用的燃料是岩石，使用一种重元素聚变的黑科技提供能源。</p><p>这种“行星飞船”的优点就是可以使生态系统最大化，总所周知，生态系统越大越稳定，只有非常稳定的生态系统才能长期在太空中流浪。但是缺点也非常明显，工程量巨大，人类对地球的了解还非常粗浅，能否实现还是个未知数。而刘慈欣就把这壮举呈现在了《流浪地球》这部小说中了。</p><p>关于这类的“行星飞船”的设定，我第一次见到是在《龙珠》的一部剧场版中。《ドラゴンボールZ 超サイヤ人だ孫悟空》（译名：龙珠Z剧场版4：超级赛亚人孙悟空，1991年出品）。讲的是在那美克星爆炸中幸存的超级那美克星人（没错跟短笛大魔王一个种族，比短笛更强）史拉格大王想把地球纳入自己的统治范围，并将地球改造成一艘宇宙飞船。我看这部剧场版时大概还是小学生，当时我就对这个把地球改造成宇宙飞船的设定印象深刻。</p><p>但是《龙珠》毕竟是热血格斗片，就算有很多黑科技也是魔幻的科幻（雾），片中只是提到史拉格大王非常喜欢这颗年轻漂亮的行星，决定改造成最新型的行星游艇。从仅有的片段我们可以看出，可能是要把发动机深埋进地里，而不是像《流浪地球》中那样高耸入云。（原著小说中行星发动机的高度是一万一千米，拍摄电影时重新计算过后发现数据有误差，改成了十万米）但是显然《龙珠》在制作时没有计算过发动机的尺寸。依我看，在《龙珠》的世界观中要实现行星飞船只需把孙悟空固定在地球上，然后对着太空发龟派气功波就完事了。</p><p>还有一种类似的“小行星飞船”，出自贰瓶勉的漫画《希德尼娅的骑士》（超喜欢它的画风），人类播种船希德尼娅。希德尼娅是由现实中存在的小行星579，编号1905 SD，名称为Sidonia，人类将该小行星从现实轨道上捕获并使之环绕地球运转、改造成飞船。播种船的任务是传承人类与地球物种的生命。找到能够进行地球化的行星后，如果有超过5万船员愿意移民，就放出舰载移民船对行星进行移民，播种船本身不会停留。 </p><p>具体设定如下<br>建造：公元237X-2384年在地球轨道上建造<br>出航：2384年8月2日<br>航行时间：已超过1009年<br>所属：人类文明<br>尺寸：长轴约33千米，中轴线长28千米（作品中有表现），居住区长轴约15千米，居住区短轴5千米以上<br>几何形：八角柱<br>动力：爱克斯粒子炉（爱克斯粒子，又译海埃斯粒子，被设定为在宇宙中普遍存在的微观粒子）<br>传动：喷口6组（后方4组推进用，前方2组逆向喷射用）<br>船内重力：由重力发生装置产生，单向1G（存在若干无重力区域）<br>乘员：一般船员50万人以上；不死船员约26人<br>速度：巡航速度为宏观高速（亚光速），推定平均速度约87195千米每秒。最大速度未知（不能进行空间跳跃，不过也能从星际空间接近其他星系） </p><h2 id="小说本身"><a href="#小说本身" class="headerlink" title="小说本身"></a>小说本身</h2><p>抛开这些设定，我们回到小说本身。<br>刘慈欣的作品给我震撼的除了无敌的科幻设定，还有宏大科幻背景下对人类的描写。这里的人类指的是在不同的社会背景下，对人类整体的心理、道德和价值观的把握。</p><p>在《流浪地球》中，有一段对话：</p><blockquote><p>爸爸突然想起了一件事，“呵，忘了告诉你们，我爱上了黎星，我要离开你们和她在一起。”<br>“她是谁？”妈妈平静地问。<br>“我的小学老师。”我替爸爸回答。我升入中学已两年，不知道爸爸和小星老师是怎么认识的，也许是在两年前那个毕业仪式上？<br>“那你去吧。”妈妈说。<br>“过一阵我肯定会厌倦，那时我就回来，你看呢？”<br>“你要愿意当然行。”妈妈的声音像冰冻的海面一样平稳，但很快激动起来， “啊，这一颗真漂亮，里面一定有全息散射体！”她指着刚在空中开放的一朵焰火，真诚地赞美着。</p></blockquote><p>婚姻和爱情在我们这个时代是人生最重要的事情之一，但是在整个人类面临巨大的危机时，生存和延续成为了人类唯一的渴望，对于婚姻和爱情人们都已经感到淡然。</p><p>还有在地下城涌入岩浆逃亡的场景：</p><blockquote><p>古代曾有过一个伦理学问题：当洪水到来时，一个只能救走一个人的男人，是去救他的父亲呢，还是去救他的儿子？在这个时代的人看来，提出这个问题很不可理解。<br>当我到达中心广场时，看到人们已按年龄排起了长长的队。最靠近电梯口的是由机器人保育员抱着的婴儿，然后是幼儿园的孩子，再往后是小学生……</p></blockquote><p>与正常人类争先恐后逃亡相反，人们按照年龄排起了长队，最后的人就等待着死亡，每个人都冷静的可怕，这种与正常的求生欲相违背的冷静又映衬出流浪地球计划的宏大。</p><p>类似的描写还出现在了刘慈欣的其它作品中，大家最熟悉的《三体》中三体危机初期的大低谷人类相食、太阳系被二向箔降维，程心坐超光速飞船出逃时人们的疯狂报复等。这些关于人类整体的描写是刘慈欣小说中不可或缺的元素，是小说整个背景设定厚重的原因之一。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>除了《流浪地球》刘慈欣还有很多非常有趣的短篇小说。我只安利三篇。<del>多了你也不会去看</del></p><h4 id="地球大炮"><a href="#地球大炮" class="headerlink" title="地球大炮"></a>地球大炮</h4><p>同样是改造地球，这篇小说中地球被挖了一个贯穿的隧道，这样一个通道有非常多的作用。如发射卫星、飞船，只需把飞船丢入真空隧道，先靠重力加速，跌落到地心，再靠电磁感应在另外一半隧道加速，最后就能在地球的另外一端发射出去。</p><p>小说中还讲了一枚螺丝钉掉入了隧道引起的事故，堪比黑洞的脑洞。</p><h4 id="带上她的眼睛"><a href="#带上她的眼睛" class="headerlink" title="带上她的眼睛"></a>带上她的眼睛</h4><p>在刘慈欣的所有小说中，最让我感到惊艳的就是《带上她的眼睛》，这篇科幻部分着墨非常少，属于清新脱俗的作品。</p><h4 id="时间移民"><a href="#时间移民" class="headerlink" title="时间移民"></a>时间移民</h4><p>关于未来人类的生存方式的思考，最让我震撼的是人类完全脱离了物质世界，生活在计算机模拟的世界中，每个人在自己的世界中成为神。又引出了经典的关于缸中之脑的思考。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title> M I T O S I S S I M U L A T I O N</title>
      <link href="/2019/M-I-T-O-S-I-S-S-I-M-U-L-A-T-I-O-N/"/>
      <url>/2019/M-I-T-O-S-I-S-S-I-M-U-L-A-T-I-O-N/</url>
      
        <content type="html"><![CDATA[<h1 id="有丝分裂模拟"><a href="#有丝分裂模拟" class="headerlink" title="有丝分裂模拟"></a>有丝分裂模拟</h1><p>点击分裂</p><p><del>点击判定不是很完善</del></p><div id="container" style="width:400px"></div><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;var cells = [];function setup() {  var myCanvas = createCanvas(ww,300);    myCanvas.parent("container");    cells.push(new Cell());}function draw() {    background(51);    for (var i = 0; i < cells.length; i++) {        cells[i].move();        cells[i].show();        cells[i].grow();    }}function mousePressed() {    for (var i = cells.length - 1; i >= 0; i--) {        if (cells[i].clicked(mouseX, mouseY)) {            cells.push(cells[i].mitosis());            cells.push(cells[i].mitosis());            cells.splice(i, 1);            break;        }        }    }    function Cell(pos, r, c) {    if (pos) {        this.pos = pos.copy();    } else {        this.pos = createVector(random(width), random(height))    }    this.r = r || 30;    this.biggest = 40;    this.c = c || color(105, 239, 254, 100);    this.clicked = function (x, y) {        var d = dist(this.pos.x, this.pos.y, x, y);        if (d < this.r) {            return true;        } else {            return false;        }    }    this.move = function () {        var vel = p5.Vector.random2D();        this.pos.add(vel);        this.pos.x = constrain(this.pos.x, 0 + this.r, width - this.r);        this.pos.y = constrain(this.pos.y, 0 + this.r, height - this.r);    }    this.grow = function () {        if(this.r<this.biggest){            this.r += 0.05;        }    }    this.mitosis = function () {        // this.pos.x += random(-this.r, this.r)        this.newpos = createVector(this.pos);        var cell = new Cell(this.pos, this.r * 0.8, this.c);        return cell;    }    this.show = function () {        fill(this.c);        noStroke();        // rect(this.pos.x,this.pos.y,10,10);s        ellipse(this.pos.x, this.pos.y, this.r, this.r);    }}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>S N A K E</title>
      <link href="/2019/S-N-A-K-E/"/>
      <url>/2019/S-N-A-K-E/</url>
      
        <content type="html"><![CDATA[<h1 id="S-N-A-K-E"><a href="#S-N-A-K-E" class="headerlink" title="S N A K E"></a>S N A K E</h1><p>一个贪吃蛇小游戏 <del>不是很完善</del></p><p>上下左右方向键控制移动</p><p>请用电脑打开</p><div id="container" style="width:400px"></div><script type="text/javascript">var s;var scl = 20;var food;const ww = document.getElementById("container").offsetWidth-40;function setup() {  var myCanvas = createCanvas(ww,400);    myCanvas.parent("container");    s = new Snake();    frameRate(10);    pickLocation();}function pickLocation() {    var cols = floor(width / scl);    var rows = floor(height / scl);    food = createVector(floor(random(cols)), floor(random(rows)));    food.mult(scl);}function draw() {    background(50);    s.update();    s.show();    if (s.eat(food)) {        pickLocation();        s.len += 1;    }    fill(255, 0, 100);    rect(food.x, food.y, scl, scl);}function keyPressed() {    if (keyCode === UP_ARROW) {        s.dir(0, -1);    }    else if (keyCode === DOWN_ARROW) {        s.dir(0, 1);    }    else if (keyCode === RIGHT_ARROW) {        s.dir(1, 0);    }    else if (keyCode === LEFT_ARROW) {        s.dir(-1, 0);    }}function Snake() {    this.x = 0;    this.y = 0;    this.xspeed = 1;    this.yspeed = 0;    this.len = 1;    this.tail = [];    this.update = function () {        if (this.len === this.tail.length) {            for (var i = 0; i < this.tail.length - 1; i++) {                this.tail[i] = this.tail[i + 1];            }        }        this.tail[this.len - 1] = createVector(this.x, this.y);        this.x += this.xspeed * scl;        this.x = constrain(this.x, 0, width - scl);        this.y += this.yspeed * scl;        this.y = constrain(this.y, 0, height - scl);    }    this.show = function () {        fill(200);        for (var i = 0; i < this.len; i++) {            rect(this.tail[i].x, this.tail[i].y, scl, scl);        }        // rect(this.x, this.y, scl, scl);    }    this.eat = function (pos) {        var d = dist(this.x, this.y, pos.x, pos.y);        if (d < 1) {            return true;        } else {            return false;        }    }    this.dir = function (x, y) {        this.xspeed = x;        this.yspeed = y;    }}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>S T A R F I E L D</title>
      <link href="/2019/S-T-A-R-F-I-E-L-D/"/>
      <url>/2019/S-T-A-R-F-I-E-L-D/</url>
      
        <content type="html"><![CDATA[<h1 id="S-T-A-R-F-I-E-L-D"><a href="#S-T-A-R-F-I-E-L-D" class="headerlink" title="S T A R F I E L D"></a>S T A R F I E L D</h1><p>请点击黑域不同位置。</p><div id="container" style="width:400px"></div><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;var World = [];var tSpeed;function setup() {  var myCanvas = createCanvas(ww,400);    myCanvas.parent("container");  for (var i = 0; i < 300; i++) {    World.push(new star());  }}function draw() {  tSpeed = map(mouseX, 0, width, 0, 20);  background(0);  translate(width / 2, height / 2);  for (var i = 0; i < World.length; i++) {    World[i].Execute();  }}function star() {  this.x = random(-width / 2, width / 2);  this.y = random(-height / 2, height / 2);  this.z = random(width);  this.Show = function () {    fill(255);    noStroke();    this.rx = map(this.x / this.z, 0, 1, 0, width);    this.ry = map(this.y / this.z, 0, 1, 0, width);    this.size = map(this.z, 0, width, 12, 0);    ellipse(this.rx, this.ry, this.size);  }  this.Create = function () {    this.z -= tSpeed;    if (this.z < 1) {      this.z = width;    }  }  this.Execute = function () {    this.Create();    this.Show();  }}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P U R P L E R A I N</title>
      <link href="/2019/P-U-R-P-L-E-R-A-I-N/"/>
      <url>/2019/P-U-R-P-L-E-R-A-I-N/</url>
      
        <content type="html"><![CDATA[<h1 id="P-U-R-P-L-E-R-A-I-N"><a href="#P-U-R-P-L-E-R-A-I-N" class="headerlink" title="P U R P L E R A I N"></a>P U R P L E R A I N</h1><p>模 拟 下 一 场 紫 色 的 雨</p><p><div id="container" style="width:400px"></div></p><script type="text/javascript">var Stars = [];  const ww = document.getElementById("container").offsetWidth-40;function setup() {  var myCanvas = createCanvas(ww,400);    myCanvas.parent("container");  for (var i = 0; i < 600; i++) {    Stars.push(new Star());  }}function draw() {  background(230, 230, 250);  for (var i = 0; i < Stars.length; i++) {    Stars[i].show();    Stars[i].updata();  }}function Star() {  this.x = random(width);  this.y = random(-400,-0);  this.z = random(0,100);  this.yspeed = map(this.z,0,100,2,7);  this.len = map(this.z,0,100,7,12);  this.show = function () {    strokeWeight(map(this.z,0,100,0,2))    print(this.yspeed);    stroke(138, 43, 226);    line(this.x, this.y, this.x, this.y + this.len);  }  this.updata = function () {    this.y += this.yspeed;    this.yspeed += 0.2;    if(this.y>360){      this.y = random(-400,0) ;      this.yspeed = 2;    }  }}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C O L O R F A L L</title>
      <link href="/2019/C-O-L-O-R-F-A-L-L/"/>
      <url>/2019/C-O-L-O-R-F-A-L-L/</url>
      
        <content type="html"><![CDATA[<h1 id="C-O-L-O-R-F-A-L-L"><a href="#C-O-L-O-R-F-A-L-L" class="headerlink" title="C O L O R F A L L"></a>C O L O R F A L L</h1><p>尝试用手指在下面空白区域滑动。</p><div id="container" style="width:400px"></div><script type="text/javascript">const ww = document.getElementById("container").offsetWidth-40;var dots = [];var isCreatable = false;function setup() {  var myCanvas = createCanvas(ww,400);    myCanvas.parent("container");}function draw() {  background(220,232,232);  if (isCreatable) {    dots.push(new Dot(mouseX, mouseY));    print(dots.length);  }  for (var i = 0; i<dots.length; i++) {    dots[i].show();    dots[i].grow();  }}function mousePressed() {  isCreatable = true;}function mouseReleased() {  isCreatable = false;}function Dot(px, py) {  this.x = px;  this.y = py;  this.r = 7;  this.l = 0;  this.growSpeed = 2;  this.colR = random(255);   this.colG = random(255);  this.colB = random(255);  this.show = function() {    noStroke();    fill(this.colR, this.colG, this.colB);    ellipse(this.x, this.y, this.r*2, this.r*2);    rect(this.x-this.r, this.y, this.r*2, this.l);    ellipse(this.x, this.y+this.l, this.r*2, this.r*2);  }  this.grow = function() {    if (this.l<height) {      this.l+=this.growSpeed;    }  }}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABOUT</title>
      <link href="/1900/about/"/>
      <url>/1900/about/</url>
      
        <content type="html"><![CDATA[<p>He never grew up,but he never stop growing.</p><p><img src="http://pic.drafff.art//drafff/20190923c1test00014bw_720x1024.jpg" width="250" style="display: inline; float: left; "></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
